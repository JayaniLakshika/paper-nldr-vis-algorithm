---
title: "Hexagonal binning algorithm"
format: pdf
editor: visual
---

```{r}
#| echo: false
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo = FALSE
)
```

```{r}
library(ggplot2)
library(dplyr)
library(quollr)
library(readr)
library(ggforce)
library(patchwork)

theme_set(theme_linedraw() +
   theme(
     #aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "none", 
     legend.title = element_text(size=5), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm')
   )
)
```

## Computing hexagon grid configurations

Given range of embedding component, $r_2$, number of bins along the x-axis, $b_1$, and buffer proportion, $q$, hexagonal starting point coordinates, $s_1 = -q$, and $s_2 = -q \times r_2$. The purpose is to find width of the hexagon. $a_1$, and number of bins along the y-axis, $b_2$.

```{r}
# umap_scurve <- read_rds(file = "data/s_curve/s_curve_umap.rds") 
# 
# scurve_scaled_obj <- gen_scaled_data(
#   data = umap_scurve)
# 
# umap_scurve_scaled <- scurve_scaled_obj$scaled_nldr
# lim1 <- scurve_scaled_obj$lim1
# lim2 <- scurve_scaled_obj$lim2
# r2 <- diff(lim2)/diff(lim1)
# 
# a1 <- calc_bins_y(bin1 = 6, q = 0.1, r2 = r2)$a1
r2 <- 1.643542
a1 <- 0.2087578
```

```{r}
all_centroids_df <- gen_centroids(bin1 = 6, r2 = r2)
```

```{r}
hex_grid <- gen_hex_coord(all_centroids_df, a1 = a1)
```

```{r}
hex_param_vis <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
    geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
    geom_point(data = all_centroids_df, aes(x = c_x, y = c_y), color = "#31a354") +
    geom_point(data = all_centroids_df |> dplyr::filter(hexID == 1), aes(x = c_x, y = c_y), color = "black") + ## starting point
    geom_rect(aes(xmin = 0 - 0.03, xmax = 1 - 0.03, ymin = 0 - 0.05, ymax = r2 - 0.05), fill = "white", color = "black", alpha = 0, linewidth = 1) +
    geom_segment(x = 0 - 0.03, y = -0.35, xend = 1 - 0.03, yend = -0.35,
                 arrow = arrow(length = unit(0.03, "npc"), ends = "both"), color = "black")+
    annotate("text", x=0.5, y=-0.45, label= "r1", color = "black") +
    geom_segment(x = -0.25, y = 0 - 0.05, xend = -0.25, yend = r2 - 0.05,
                 arrow = arrow(length = unit(0.03, "npc"), ends = "both"), color = "black")+ 
    annotate("text", x=-0.35, y=1, label= "r2", color = "black") +
    geom_segment(x = -0.1 + 0.2087578, y = -0.15, xend = -0.1 + 0.2087578*2, yend = -0.15,
                   arrow = arrow(length = unit(0.03, "npc"), ends = "both"), color = "black")+ # a1 = 0.2087578
    annotate("text", x=0.2, y=-0.25, label= "a1", color = "black") +
    geom_segment(x = -0.15, y = -0.1*r2 + 0.1807896*2, xend = -0.15, yend = -0.1*r2 + 0.1807896*3,
                     arrow = arrow(length = unit(0.03, "npc"), ends = "both"), color = "black")+ # a2 = 0.1807896
    annotate("text", x=-0.15, y=0.45, label= "a2", color = "black") +
    annotate("text", x=-0.18, y=-0.35, label= "(s1, s2)", color = "black") + ## starting point
  coord_equal()
```

```{r}
#| label: fig-hex-param
#| fig-cap: "Notations for hexagonal grid configurations."
#| out-height: 30%
#| fig-pos: H

hex_param_vis
```

Geometric arguments give rise to the following constraints.

$\text{min }a_1 \text{ s.t.}$

$$
s_1 - \frac{a_1}{2} < 0,
$$ {#eq-equation1}

$$
s_1 + (b_1 - 1) \times a_1 > 1,
$$ {#eq-equation2}

$$
s_2 - \frac{a_2}{2} < 0,
$$ {#eq-equation4}

$$
s_2 + (b_2 - 1) \times a_2 > r_2.
$$ {#eq-equation5}

Since $a_1$ and $a_2$ are distances,

$$
a_1, a_2 > 0.
$$ Also, $(s_1, s_2) \in (-0.1, -0.05)$ as these are multiplicative offsets in the negative direction.

@eq-equation1 can be rearranged as,

$$
a_1 > 2s_1
$$

which given $s_1 < 0$ and $a_1 > 0$ will *always* be true. The same logic follows for @eq-equation4 and substituting $a_2 = \frac{\sqrt{3}}{2}a_1$, and $s_2 = -q \times r_2$ to @eq-equation4 can be written as,

$$
a_1 > -\frac{4}{\sqrt{3}}qr_2
$$

Also, substituting $a_2 = \frac{\sqrt{3}}{2}a_1$, $s_2 = -q \times r_2$ and rearranging @eq-equation5 gives:

$$
a_1 > \frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)}.
$$ {#eq-equation6}

Similarly, substituting $s_1 = -q$ @eq-equation2 becomes,

$$
a_1 > \frac{(1 + q)}{(b_1 - 1)}.
$$ {#eq-equation7}

This is a linear optimization problem. Therefore, the optimal solution must occur on a vertex. So, by setting @eq-equation6 equals to @eq-equation7 gives,

$$
\frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)} = \frac{(1 + q)}{(b_1 - 1)}.
$$ After rearranging this,

$$
b_2 = 1 + \frac{2r_2(b_1 - 1)}{\sqrt{3}}
$$

and since $b_2$ should be an integer,

$$
b_2 = \Big\lceil1 +\frac{2r_2(b_1 - 1)}{\sqrt{3}}\Big\rceil.
$$ {#eq-equation8}

Furthermore, with known $b_1$ and $b_2$, by considering @eq-equation2 or @eq-equation5 as the *binding* or *active constraint*, can compute $a_1$.

If @eq-equation2 is active, then,

$$
\frac{(1 + q)}{(b_1 - 1)} < \frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)}.
$$

Rearranging this gives,

$$
r_2 > \frac{\sqrt{3}(b_2 - 1)}{2(b_1 - 1)}.
$$

Therefore, if this equality is true, then $a_1 = \frac{(1+q)}{(b_1 - 1)}$, otherwise, $a_1 = \frac{2r_2(1+q)}{\sqrt{3}(b_2 - 1)}$.

\newpage

## Binning the data

Points are assigned to the bin they fall into based on the nearest centroid. If a point is equidistant from multiple centroids, it is assigned to the centroid with the lowest hexagonal bin ID.

```{r}
all_centroids_df <- gen_centroids(bin1 = 3, r2 = r2)

hex_grid <- gen_hex_coord(all_centroids_df, a1 = 0.5218947)

## Data to generate circle
circles <- data.frame(
  x = c(0.422, 0.683),
  y = c(0.740, 1.19),
  r = rep(0.301316, 2)
)

emb_df1 <- tibble(emb1 = 0.58, emb2 = 0.93) |>
  add_row(emb1 = 0.5, emb2 = 1.01)

assign_data_vis1 <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_point(data = emb_df1, aes(x = emb1, y = emb2), color = "black", size = 0.7) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 5, colour = "#bdbdbd") +
  geom_circle(data = circles, aes(x0 = x, y0 = y, r = r), fill = NA) +
  geom_segment(x = 0.58, y = 0.93, xend = 0.44, yend = 0.76, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#969696") +
  geom_segment(x = 0.5, y = 1.01, xend = 0.68, yend = 1.16, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#969696")

assign_data_vis2 <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 5, colour = "#bdbdbd")
```

```{r}
#| fig-width: 9
#| fig-height: 6
assign_data_vis1 + assign_data_vis2 +
  plot_layout(ncol = 2)
```

```{r}

## To generate embedding data
emb_df <- tibble::tibble(emb1 = 0.37, emb2 = 0.3) |>
  add_row(emb1 = 0.526, emb2 = 1.1) |>
  add_row(emb1 = 0.735, emb2 = 1.1) |>
  add_row(emb1 = 0.631, emb2 = 1.22) |>
  add_row(emb1 = 0.735, emb2 = 1.16) |>
  add_row(emb1 = 0.683, emb2 = 1.19) |>
  add_row(emb1 = 0.735, emb2 = 1.04) |>
  add_row(emb1 = 0.631, emb2 = 0.981) |>
  add_row(emb1 = 0.683, emb2 = 1.0105) |>
  add_row(emb1 = 0.526, emb2 = 1.04) |>
  add_row(emb1 = 0.5785, emb2 = 1.0105) |> 
  add_row(emb1 = 0.526, emb2 = 1.16) |>
  add_row(emb1 = 0.5785, emb2 = 1.19)

## Data to generate circle
circles <- data.frame(
  x = c(0.318, 0.422),
  y = c(0.197,0.378),
  r = rep(0.1205264,2)
)

assign_data_vis <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 2) +
  geom_point(data = emb_df, aes(x = emb1, y = emb2), color = "#253494", size = 0.5) +
  geom_circle(data = circles, aes(x0 = x, y0 = y, r = r), fill = NA) +
  geom_segment(x = 0.37, y = 0.3, xend = 0.422, yend = 0.378, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.526, y = 1.1, xend = 0.45, yend = 1.1, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.735, y = 1.1, xend = 0.66, yend = 1.1, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.631, y = 1.22, xend = 0.631, yend = 1.15, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.735, y = 1.16, xend = 0.65, yend = 1.12, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.735, y = 1.04, xend = 0.735, yend = 0.95, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.683, y = 1.19, xend = 0.65, yend = 1.12, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.631, y = 0.981, xend = 0.55, yend = 0.95, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.683, y = 1.0105, xend = 0.7, yend = 0.95, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.526, y = 1.04, xend = 0.526, yend = 0.95, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.5785, y = 1.0105, xend = 0.536, yend = 0.97, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.526, y = 1.16, xend = 0.49, yend = 1.12, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  geom_segment(x = 0.5785, y = 1.19, xend = 0.58, yend = 1.12, 
               arrow = arrow(length = unit(0.02, "npc")), color = "black") +
  coord_equal()
    
```

```{r}
#| label: fig-assign-data
#| fig-cap: "Binning the data. Points are assigned to the nearest centroid. If a point is equidistant from multiple centroids, assigned to the lowest centroid."
 
assign_data_vis
```
