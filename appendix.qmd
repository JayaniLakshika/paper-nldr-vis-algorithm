---
title: "Appendix: Looking at Non-Linear Dimension Reductions as Models in the Data Space"
format: 
    jasa-pdf:
        keep-tex: true
    jasa-html: default
author:
  - name: Jayani P. Gamage
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-6265-6481
    email: jayani.piyadigamage@monash.edu
    url: https://jayanilakshika.netlify.app/
  - name: Dianne Cook
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-3813-7155
    email: dicook@monash.edu 
    url: http://www.dicook.org/
  - name: Paul Harrison
    affiliations:
      - name: Monash University
        department: MGBP, BDInstitute
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-3980-268X
    email: 	paul.harrison@monash.edu
    url: 
  - name: Michael Lydeamore
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0001-6515-827X
    email: michael.lydeamore@monash.edu
    url: https://www.michaellydeamore.com/
  - name: Thiyanga S. Talagala
    affiliations:
      - name: University of Sri Jayewardenepura
        department: Statistics
        address: Gangodawila
        city: Nugegoda 
        country: Sri Lanka
        postal-code: 10100
    orcid: 0000-0002-0656-9789
    email: ttalagala@sjp.ac.lk 
    url: https://thiyanga.netlify.app/
tbl-cap-location: bottom
bibliography: paper.bib 
header-includes: | 
  \usepackage{amsmath}
  \usepackage{float}
  \usepackage{hyperref}
  \usepackage[utf8]{inputenc}
  \usepackage{bm}
  \def\tightlist{}
  \usepackage{setspace}
  \newcommand\pD{$p\text{-}D$}
  \newcommand\kD{$k\text{-}D$}
  \newcommand\dD{$d\text{-}D$}
  \newcommand\gD{$2\text{-}D$}
  \newcommand{\To}{\textbf{to}~}
  \usepackage{abstract}
  \renewcommand{\abstractname}{}    % clear the title
  \renewcommand{\absnamepos}{empty} % originally center
---

```{r include=FALSE}
# Set up chunk for for knitr
knitr::opts_chunk$set(
  fig.width = 5,
  fig.height = 5,
  fig.align = "center",
  out.width = "100%",
  code.line.numbers = FALSE,
  fig.retina = 4,
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  dev.args = list(pointsize = 11)
)
```

```{r include=FALSE}
#| label: install-libraries
#| warning: false
#| echo: false

options(repos = c(CRAN = "https://cran.rstudio.com")) # Setup mirror

packages_to_check <- c("remotes", "tidyverse", "patchwork", "colorspace", "kableExtra", "conflicted", "ggforce")

for (pkg in packages_to_check) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    message(paste("Installing package:", pkg))
    install.packages(pkg)
  } else {
    installed_version <- packageVersion(pkg)
    available_version <- tryCatch({
      utils::packageDescription(pkg)$Version
    }, error = function(e) NA) # Handle cases where package info isn't readily available

    if (!is.na(available_version) && installed_version < package_version(available_version)) {
      message(paste("A newer version of package", pkg, "is available. Updating..."))
      install.packages(pkg)
    } else {
      message(paste("Package", pkg, "is up-to-date (version", installed_version, ")."))
    }
  }
}

if (!requireNamespace("quollr", quietly = TRUE)) {
  remotes::install_github("JayaniLakshika/quollr")
}


```

```{r}
#| label: load-libraries
#| warning: false
#| echo: false
library(quollr)
library(tibble)
library(dplyr)
library(ggplot2)
library(readr)
library(tidyr)
library(patchwork)
library(colorspace)
library(kableExtra)
library(conflicted)
library(ggforce)

conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
```

```{r}
#| label: plot-theme
theme_set(theme_linedraw() +
   theme(
     #aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "bottom", 
     legend.title = element_blank(), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm'),
     plot.margin = margin(0, 0, 0, 0)
   )
)
```

```{r}
#| label: import-scripts
source("scripts/additional_functions.R")
```

```{r}
#| label: code-setup
set.seed(20240110)
```

```{r}
#| label: tbl-notation
#| tbl-cap: "Summary of notation for describing new methodology."
# Notation used in the paper

notation_df <- read_csv("misc/notation.csv")

# Create the table
kable(notation_df, 
      format = "latex", 
      booktabs = TRUE, escape = FALSE) |>
  kable_styling(position = "center", 
                full_width = FALSE, 
                font_size = 12) |>
  row_spec(0, bold = TRUE) |>
  column_spec(1:2, width = c("3cm", "12cm"))
```

\newpage

## Computing hexagon grid configurations

Given range of embedding component, $r_2$, number of bins along the x-axis, $b_1$, and buffer proportion, $q$, hexagonal starting point coordinates, $s_1 = -q$, and $s_2 = -q \times r_2$. The purpose is to find width of the hexagon. $a_1$, and number of bins along the y-axis, $b_2$.

```{r}
umap_scurve <- read_rds(file = here::here("data/s_curve/s_curve_umap.rds")) 

scurve_scaled_obj <- gen_scaled_data(
  nldr_data = umap_scurve)

sc_ltr_pos <- c(0.08, 0.96)
sc_xlims <- c(-0.5, 1.47)
sc_ylims <- c(-0.32, 2.1)
```

<!--Full hexagon grid with UMAP data-->

```{r}
## Compute hexbin parameters
num_bins_x_scurve <- 7

## hexagon binning to have regular hexagons
hb_obj_scurve <- hex_binning(
  nldr_obj = scurve_scaled_obj, 
  bin1 = num_bins_x_scurve, 
  q = 0.1)

## Data set with all centroids
all_centroids_df <- hb_obj_scurve$centroids

## Generate all coordinates of hexagons
hex_grid <- hb_obj_scurve$hex_poly

a1_temp <- hb_obj_scurve$a1
a2_temp <- hb_obj_scurve$a2
l_temp <- quad(a=3, b = 2 * a2_temp, c = -(a2_temp^2 + a1_temp^2))

```

```{r}
# Code to draw illustration for notation
start_pt <- all_centroids_df |> 
  filter(hexID == 1)

d_rect <- tibble(x1min = 0, 
                 x1max = 1,
                 x2min = 0,
                 x2max = diff(scurve_scaled_obj$lim2)/diff(scurve_scaled_obj$lim1))

hex_grid_temp40 <- hex_grid |> 
  filter(hex_poly_id == 53)

c_start <- tibble(s1 = 0.03, s2 = -0.05)

a1 <- tibble(x = all_centroids_df$c_x[4],
             xend = all_centroids_df$c_x[5],
             y = all_centroids_df$c_y[29],
             yend = all_centroids_df$c_y[29],
             label = expression(a[1]))
a2 <- tibble(x = all_centroids_df$c_x[39],
             xend = all_centroids_df$c_x[39],
             y = all_centroids_df$c_y[39],
             yend = all_centroids_df$c_y[47],
             label = expression(a[2]))

l <- tibble(x = hex_grid_temp40$x[2],
            xend = hex_grid_temp40$x[3],
            y = hex_grid_temp40$y[2],
            yend = hex_grid_temp40$y[3],
            label = expression(l))

hex_param_vis <- ggplot() + 
    geom_polygon(data = hex_grid, 
                        aes(x = x, 
                            y = y, 
                            group = hex_poly_id),
                 fill = "white", 
                 color = "#bdbdbd") +
    geom_point(data = all_centroids_df, aes(
      x = c_x, 
      y = c_y), 
      color = "#31a354", size = 0.9) +
    geom_point(data = start_pt, aes(x = c_x, 
                                    y = c_y), 
               color = "black") + 
    geom_rect(data=d_rect, 
              aes(xmin = x1min - c_start$s1,# - c_start$s1, 
                  xmax = x1max - c_start$s1,# - c_start$s1, 
                  ymin = x2min - c_start$s2,# - c_start$s2, 
                  ymax = x2max - c_start$s2),# - c_start$s2), 
              fill = "white", 
              color = "black", 
              alpha = 0, 
              linewidth = 0.7) +
    geom_point(data=d_rect, aes(x=x1min - c_start$s1, 
                                y=x2min - c_start$s2)) + 
    geom_point(data=d_rect, aes(x=x1max - c_start$s1, 
                                y=x2min - c_start$s2)) + 
    geom_point(data=d_rect, aes(x=x1min - c_start$s1, 
                                y=x2max - c_start$s2)) + 
    annotate("text", x=d_rect$x1min - c_start$s1, 
                     y=d_rect$x2min - c_start$s2,
                     label = "(0,0)", 
             hjust=-0.1, vjust=-0.3, size = 8) + 
    annotate("text", x=d_rect$x1max - c_start$s1, 
                     y=d_rect$x2min - c_start$s2,
                     label = "(0,1)", 
             hjust=1.1, vjust=-0.3, size = 8) + 
    annotate("text", x=d_rect$x1min - c_start$s1, 
                     y=d_rect$x2max - c_start$s2,
                     label = expression(group("(", 
                        list(0, y[2][max]),")")), 
            hjust=-0.1, vjust=1.2, size = 8) + 
    geom_segment(data=d_rect, aes(
      x = x1min  - c_start$s1, # 0 - 0.03, 
      y = -0.35, 
      xend = x1max - c_start$s1, #1 - 0.03, 
      yend = -0.35), #-0.35),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
                 color = "black")+
    annotate("text", x=0.5, y=-0.45, 
             label = expression(r[1]), color = "black", size = 8) +
    geom_segment(data=d_rect, aes(
      x = -0.25, 
      y = x2min - c_start$s2, #0 - 0.05, 
      xend = -0.25, 
      yend = x2max - c_start$s2), #r2 - 0.05),
      arrow = arrow(length = unit(0.03, "npc"),
                       ends = "both"), 
                 color = "black")+ 
    annotate("text", x=-0.35, y=1, 
             label = expression(r[2]), color = "black", size = 8) +
    geom_segment(data = a1, aes(
      x = x, #-0.1 + 0.2087578, 
      y = y, #-0.15, 
      xend = xend, #-0.1 + 0.2087578*2, 
      yend = yend), #-0.15),
      arrow = arrow(length = unit(0.03, "npc"),
        ends = "both"), 
        color = "black")+ # a1 = 0.2087578
    annotate("text", 
             x=(a1$x+a1$xend)/2, 
             y=a1$y, 
             label = expression(a[1]), 
             color = "black",
             vjust = 1.2, size = 8) +
    geom_segment(data = a2, aes(
      x = x, #-0.15, 
      y = y, #-0.1*r2 + 0.1807896*2, 
      xend = xend, #-0.15, 
      yend = yend), #-0.1*r2 + 0.1807896*3),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
      color = "black") + # a2 = 0.1807896
    annotate("text", x=a2$x, y=(a2$y+a2$yend)/2, 
             label = expression(a[2]), 
             color = "black", hjust=-0.2, size = 8) +
    annotate("text", x=-0.18, y=-0.25, 
      label = expression(group("(", list(s[1], s[2]), ")")),
      color = "black", size = 8) +
  geom_segment(data = l, aes(
      x = x, #-0.15, 
      y = y, #-0.1*r2 + 0.1807896*2, 
      xend = xend, #-0.15, 
      yend = yend), #-0.1*r2 + 0.1807896*3),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
      color = "black") + 
    annotate("text", x=l$x + 0.03, y=(l$y+l$yend)/2, 
             label = expression(l), 
             color = "black", hjust=-0.2, size = 8) +
  coord_equal()  
```

```{r}
#| label: fig-hex-param
#| fig-cap: "The components of the hexagon grid illustrating notation."
#| out-width: 30%
#| fig-pos: H

hex_param_vis
```

Geometric arguments give rise to the following constraints.

$\text{min }a_1 \text{ s.t.}$

$$
s_1 - \frac{a_1}{2} < 0,
$$ {#eq-equation1}

$$
s_1 + (b_1 - 1) \times a_1 > 1,
$$ {#eq-equation2}

$$
s_2 - \frac{a_2}{2} < 0,
$$ {#eq-equation4}

$$
s_2 + (b_2 - 1) \times a_2 > r_2.
$$ {#eq-equation5}

Since $a_1$ and $a_2$ are distances,

$$
a_1, a_2 > 0.
$$ Also, $(s_1, s_2) \in (-0.1, -0.05)$ as these are multiplicative offsets in the negative direction.

@eq-equation1 can be rearranged as,

$$
a_1 > 2s_1
$$

which given $s_1 < 0$ and $a_1 > 0$ will *always* be true. The same logic follows for @eq-equation4 and substituting $a_2 = \frac{\sqrt{3}}{2}a_1$, and $s_2 = -q \times r_2$ to @eq-equation4 can be written as,

$$
a_1 > -\frac{4}{\sqrt{3}}qr_2
$$

Also, substituting $a_2 = \frac{\sqrt{3}}{2}a_1$, $s_2 = -q \times r_2$ and rearranging @eq-equation5 gives:

$$
a_1 > \frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)}.
$$ {#eq-equation6}

Similarly, substituting $s_1 = -q$ @eq-equation2 becomes,

$$
a_1 > \frac{(1 + q)}{(b_1 - 1)}.
$$ {#eq-equation7}

This is a linear optimization problem. Therefore, the optimal solution must occur on a vertex. So, by setting @eq-equation6 equals to @eq-equation7 gives,

$$
\frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)} = \frac{(1 + q)}{(b_1 - 1)}.
$$ 

After rearranging this,

$$
b_2 = 1 + \frac{2r_2(b_1 - 1)}{\sqrt{3}}
$$

and since $b_2$ should be an integer,

$$
b_2 = \Big\lceil1 +\frac{2r_2(b_1 - 1)}{\sqrt{3}}\Big\rceil.
$$ {#eq-equation8}

Furthermore, with known $b_1$ and $b_2$, by considering @eq-equation2 or @eq-equation5 as the *binding* or *active constraint*, can compute $a_1$.

If @eq-equation2 is active, then,

$$
\frac{(1 + q)}{(b_1 - 1)} < \frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)}.
$$

Rearranging this gives,

$$
r_2 > \frac{\sqrt{3}(b_2 - 1)}{2(b_1 - 1)}.
$$

Therefore, if this equality is true, then $a_1 = \frac{(1+q)}{(b_1 - 1)}$, otherwise, $a_1 = \frac{2r_2(1+q)}{\sqrt{3}(b_2 - 1)}$.

\newpage

## Binning the data

Points are assigned to the bin they fall into based on the nearest centroid. If a point is equidistant from multiple centroids, it is assigned to the centroid with the lowest hexagonal bin ID.

```{r}
## Compute hexbin parameters
num_bins_x_scurve <- 3

## hexagon binning to have regular hexagons
hb_obj_scurve <- hex_binning(
  nldr_obj = scurve_scaled_obj, 
  bin1 = num_bins_x_scurve, 
  q = 0.1)

## Data set with all centroids
all_centroids_df <- hb_obj_scurve$centroids

## Generate all coordinates of hexagons
hex_grid <- hb_obj_scurve$hex_poly

## Data to generate circle
circles <- data.frame(
  x = c(0.726, 0.451),
  y = c(1.27, 0.790),
  r = rep(0.32, 2)
)

emb_df1 <- tibble(emb1 = 0.61, emb2 = 0.99) |>
  add_row(emb1 = 0.54, emb2 = 1.08)

assign_data_vis1 <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_point(data = emb_df1, aes(x = emb1, y = emb2), color = "black", size = 0.7) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 5, colour = "#bdbdbd") +
  geom_circle(data = circles, aes(x0 = x, y0 = y, r = r), fill = NA) +
  geom_segment(x = 0.61, y = 0.99, xend = 0.46, yend = 0.83, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#969696") +
  geom_segment(x = 0.54, y = 1.08, xend = 0.7, yend = 1.2, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#969696")

hex_data <- hex_grid |> 
  dplyr::filter(hex_poly_id == 8)

# Create all pairs of rows
pairs <- expand_grid(row1 = 1:nrow(hex_data), row2 = 1:nrow(hex_data)) |>
  filter(row1 < row2)

# Compute middle points for each pair of rows
middle_points <- pairs |>
  rowwise() |>
  mutate(
    hex_poly_id = hex_data$hex_poly_id[row1],
    x = (hex_data$x[row1] + hex_data$x[row2]) / 2,
    y = (hex_data$y[row1] + hex_data$y[row2]) / 2
  ) |>
  ungroup() |>
  select(hex_poly_id, x, y) |>
  filter(row_number() %in% c(1, 5, 6, 10, 13, 15))

points_df <- bind_rows(hex_data, middle_points)

assign_data_vis2 <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_point(data = points_df, aes(x = x, y = y), color = "black", size = 0.7) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 5, colour = "#bdbdbd") +
  geom_segment(x = 0.175, y = 0.790, xend = -0.06, yend = 0.790, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.726, y = 0.790, xend = 0.50, yend = 0.790,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.313, y = 1.03, xend = 0.41, yend = 0.82,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.588, y = 1.03, xend = 0.48, yend = 0.82,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.313, y = 0.551, xend = 0.20, yend = 0.34,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.588, y = 0.551, xend = 0.67, yend = 0.34,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.451, y = 1.11, xend = 0.451, yend = 0.85,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.175, y = 0.949, xend = -0.02, yend = 0.82,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.175, y = 0.631, xend = 0.175, yend = 0.4,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.451, y = 0.472, xend = 0.25, yend = 0.3,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.726, y = 0.631, xend = 0.726, yend = 0.4,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.726, y = 0.949, xend = 0.5, yend = 0.82,
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd")
  
```

```{r}
#| label: fig-assign-data
#| fig-cap: "Binning the data. Points are assigned to the nearest centroid. If a point is equidistant from multiple centroids, assigned to the lowest centroid."
#| fig-width: 9
#| fig-height: 6

assign_data_vis1 + assign_data_vis2 +
  plot_layout(ncol = 2)
```

\newpage

## Area of a hexagon

The area of a hexagon is defined as $A = \frac{3\sqrt{3}}{2}l^2$, where $l$ is the side length of the hexagon. $l$ can be computed using $a_1$ and $a_2$.


```{r}
# triangle_temp <- tibble(
#   x = c(0, 4, 0),
#   y = c(0, 0, 3)
# )

triangle_line_temp <- tibble(
  x = c(4, 0, 4),
  xend = c(0, 0, 0),
  y = c(0, 0, 0),
  yend = c(0, 3, 3)
)

# triangle_arrow_temp <- tibble(
#   x = c(4 + 0.04, 0 - 0.06, 4 + 0.06),
#   xend = c(0 + 0.04, 0 - 0.06, 0 + 0.06),
#   y = c(0 - 0.04, 0 - 0.06, 0 + 0.06),
#   yend = c(0 - 0.04, 3 - 0.06, 3 + 0.06)
# )

triangle_plot <- ggplot() +
  # geom_point(
  #   data = triangle_temp,
  #   aes(
  #     x = x,
  #     y = y
  #   )
  # ) +
  geom_segment(
    data = triangle_line_temp,
    aes(
      x = x,
      xend = xend,
      y = y,
      yend = yend
    )
  ) + 
  annotate("text", x=-1.5, y= 1.5, 
           label = expression(frac(a[2] - a[1], 2)), 
           color = "black", hjust=-0.2, size = 8) + 
  annotate("text", x=1.5, y= -0.5, 
           label = expression(frac(a[1], 2)), 
           color = "black", hjust=-0.2, size = 8) + 
  annotate("text", x=2.5, y= 1.5, 
           label = expression(l), 
           color = "black", hjust=-0.2, size = 8)
```

```{r}
#| label: fig-tri-param
#| fig-cap: "The components of the right triangle illustrating notation."
#| out-width: 30%

triangle_plot
```

By applying the Pythagorean theorem, we obtain,

$$
l^2 = \left(\frac{a_1}{2}\right)^2 + \left(\frac{a_2 - l}{2}\right)^2.
$$
Next, rearranging the terms, we get,

$$
l^2 - \left(\frac{a_2 - l}{2}\right)^2 = \left(\frac{a_1}{2}\right)^2,
$$

$$
\left[l - \left(\frac{a_2 - l}{2}\right)\right]\left[l + \left(\frac{a_2 - l}{2}\right)\right] = \left(\frac{a_1}{2}\right)^2,
$$

$$
3l^2 + 2a_2l - (a_1^2 + a_2^2) = 0.
$$

Finally, by solving the quadratic equation, we compute,

$$
l = \frac{-2a_2 \pm \sqrt{4a_2^2 - 24[-(a_1^2 + a_2^2)]}}{6},
$$

$$
l = \frac{-a_2 \pm \sqrt{a_2^2 - 6[-(a_1^2 + a_2^2)]}}{3},
$$

where $l > 0$.

## Single-cell gene expression: comparison with results of scDEED recommendations

<!-- ### Comparison with results of scDEED recommendations -->

<!-- XXX What this section needs: -->

<!-- - connect this with previous section, not make it seem like a completely new. connections are: nldr used to show clustering, scDEED provides a different approach to decide which is best. -->
<!-- - why these two? assume one is the published figure, and second is one recommended by scDEED, which our results confirm is better. -->
<!-- - Refer to figure in text -->
<!-- - Fig 16 not necessary -->

<!-- CHANGES WERE MADE BASED ON THIS THINKING -->



<!-- <!-- In the field of single-cell studies, clustering is a common analytical task used to identify groups of cells with similar expression profiles. Non-linear dimensional reduction (NLDR) methods are frequently employed to visualize these clusters and help validate the results. However, it is well known that the 2D embeddings produced by t-SNE and UMAP may not accurately reflect the similarities among cell clusters. ALREADY STATED IN PREVIOUS SECTION -->  

As we were writing this paper @xia2023 appeared proposing a new method called scDEED helping to assess the validity of a \gD{} embedding. scDEED calculates a reliability score for each cell embedding based on the similarity between the cellâ€™s \gD{} embedding neighbors and its neighbors prior to embedding. A low reliability score suggests a dubious embedding. It can help in the deciding on optimal hyper-parameters. Here we illustrate how our method compares with the results from scDEED.

Following the process in @xia2023 again using the Human Peripheral Blood Mononuclear Cells (PBMC) data. Note that @xia2023 uses a different subset from the PBMC dataset used by @chen2024, which contains $31,021$ cells including cell type labels, and the gene expression levels were in the unit of log-transformed UMI count per $10,000$. They focused on three sequencing methods (inDrops, DropSeq, and SeqWell) and four common cell types Cytotoxic T cell, CD4+T cell, CD14+ Monocyte, and B cell.

For illustration purposes, we only selected cells generated with inDrops ($n=5858$ cells) and UMAP and tSNE cell embeddings. Also, @xia2023 used first $9$ principal components to generate the UMAP and tSNE. The objective is to assess the optimized layout by scDEED, and if it does not accurately represent the three clusters with small separations of the PBMC dataset, then select a reasonable \gD{} layout.

```{r}
result_umap <- read_rds(here::here('data/pbmc3k/pbmc_scdeed_umap_results.rds'))
```

```{r}
#| eval: false
result_umap |>
  kableExtra::kable(format = "latex",
                    booktabs = TRUE,
                    longtable = TRUE,
                    label = "scdeedumap") |>
  kableExtra::kable_styling(latex_options = "scale_down")
```

```{r}
#| label: fig-n_neighbors-dubious_cells
#| out-width: 50%
#| fig-pos: H
#| eval: false

result_umap |>
  filter(min.dist == 0.5) |>
  filter(n_neighbors < 240) |>
  ggplot(aes(
           x = as.numeric(n_neighbors),
           y = number_dubious_cells
         )) +
    geom_line() +
    geom_point() +
    labs(x = "n_neighbors",
         y = "Number of dubious cells") +
    theme_minimal()
```

```{r}
#| label: read-pbmc-umap-layouts
# Read a variety of different NLDR representations of PBMC
# and plot them on same aspect ratio
umap_pbmc <- read_rds("data/pbmc3k/pbmc_scdeed_umap_n_neighbors_30_min_dist_0.3.rds")
umap_pbmc <- as_tibble(umap_pbmc)
names(umap_pbmc) <- c("emb1", "emb2")
umap_pbmc <- umap_pbmc |>
  dplyr::mutate(ID = row_number())

nldr1c <- umap_pbmc |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#e41a1c') +
  interior_annotation("a")

tsne_pbmc <- read_rds("data/pbmc3k/pbmc_scdeed_tsne_perplexity_30.rds")
tsne_pbmc <- as_tibble(tsne_pbmc)
names(tsne_pbmc) <- c("emb1", "emb2")
tsne_pbmc <- tsne_pbmc |>
  dplyr::mutate(ID = row_number())

nldr2c <- tsne_pbmc |>
  ggplot(aes(x = emb1,
             y = emb2))+
  geom_point(alpha=0.1, size=1, colour='#377eb8') +
  interior_annotation("b")

```

```{r}
#| label: combine-data-pbmc-umap-tsne

error_pbmc_umap <- read_rds("data/pbmc3k/error_scdeed_pbmc_umap_30_min_dist_0.3.rds")
error_pbmc_tsne <- read_rds("data/pbmc3k/error_scdeed_pbmc_tsne_perplexity_30.rds")

error_pbmc <- bind_rows(error_pbmc_umap,
                        error_pbmc_tsne)

error_pbmc <- error_pbmc |>
  mutate(a1 = round(a1, 2)) |>
  filter(bin1 >= 5) |>
  group_by(method, a1) |>
  filter(RMSE == min(RMSE)) |>
  ungroup()
```

```{r}
#| label: error-comp-pbmc-umap

error_umap_plot_pbmc <-  plot_mse(error_pbmc) +
  scale_x_continuous(breaks = sort(unique(error_pbmc$a1))[c(1, 5, 9, 12, 15, 17, 19, 20)]) +
  scale_color_manual(values=c('#377eb8', '#e41a1c'))
```

```{r}
#| label: fig-pbmc-mse-umap
#| fig-pos: H
#| out-width: 100%
#| fig-cap: "Assessing which of the two layouts with UMAP and tSNE with different hyper-parameter setting (n_neighbors: $30$, min_dist: $0.3$ (red); n_neighbors: $30$ (blue)) on the PBMC data is the better representation using RMSE for varying binwidth ($a_1$). Colour used for the lines and points in the top plot and in the scatterplots represents UMAP and tSNE layouts (a, b). Of the two, layout b is optimal across all binwidths making it the best choice."

# Define the layout design
layout_design <- "
AA
BC
"

# Combine the plots using the layout
(error_umap_plot_pbmc + nldr1c + nldr2c) +
  plot_layout(design = layout_design)
```
The layout a (@fig-pbmc-mse-umap) is generated from the hyper-parameters suggested by @chen2024, and the layout b (@fig-pbmc-mse-umap) is with suggested hyper-parameters by scDEED to be more accurate. The layout a and b contain $46$ and $83$ dubious cells respectively. 

The RMSE vs binwidth ($a_1$) plot (@fig-pbmc-mse-umap) illustrates that our approach would suggest that scDEED is correct here, that layout b is more accurately reflecting the cluster structure in the PBMC data.

```{r}
#| label: hexbin-pbmc
training_data_pbmc <- read_rds("data/pbmc3k/pbmc_pca_50_scdeed.rds")
training_data_pbmc <- training_data_pbmc[, 1:9] |>
  mutate(ID = 1:NROW(training_data_pbmc))

names(training_data_pbmc) <- append(paste0("x", 1:9), "ID")

## Compute hexbin parameters
num_bins_x_pbmc <- 30

algo_obj_pbmc <- fit_highd_model(
  highd_data = training_data_pbmc, 
  nldr_data = umap_pbmc, 
  bin1 = num_bins_x_pbmc, 
  q = 0.1, 
  benchmark_highdens = 5)

umap_pbmc_scaled <- algo_obj_pbmc$nldr_obj$scaled_nldr
tr_from_to_df_pbmc <- algo_obj_pbmc$trimesh_data
df_bin_centroids_pbmc <- algo_obj_pbmc$model_2d
df_bin_pbmc <- algo_obj_pbmc$model_highd

umap_pbmc_scaled_with_cluster <- umap_pbmc_scaled |>
  mutate(cluster = if_else(emb1 <= 0.3, "cluster1", if_else((emb1 >= 0.75) & (emb2 <= 0.25), "cluster3", "cluster2"))) |>
  mutate(cluster = factor(cluster, levels = c("cluster1", "cluster2", "cluster3")))

trimesh_removed_pbmc <- ggplot() + 
  geom_point(
    data = umap_pbmc_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.2,
    size = 0.1
  )  +
  geom_segment(data = tr_from_to_df_pbmc, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada")) +
  interior_annotation("a1", cex = 2) +
  theme(
    aspect.ratio = 1
  )
```

```{r}
#| label: prep-pbmc-umap-model-proj

data_pbmc <- training_data_pbmc |> 
  select(-ID) |>
  mutate(type = "data")

df_b_pbmc <- df_bin_pbmc |>
  dplyr::filter(hexID %in% df_bin_centroids_pbmc$hexID) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the hexID order in df_b_with_center_data
df_b_pbmc <- df_b_pbmc[match(df_bin_centroids_pbmc$hexID, df_b_pbmc$hexID),] |>
  dplyr::select(-hexID) 

# Apply the scaling
df_model_data_pbmc <- bind_rows(data_pbmc, df_b_pbmc)
scaled_pbmc <- scale_data_manual(df_model_data_pbmc, "type") |>
  as_tibble()

scaled_pbmc_data <- scaled_pbmc |>
  filter(type == "data") |>
  select(-type)

scaled_pbmc_data_model <- scaled_pbmc |>
  filter(type == "model") |>
  select(-type)
```

```{r}
#| label: langevitour-pbmc-umap-author-proj
#| eval: false

data_pbmc_n <- data_pbmc |>
  select(-type) |>
  mutate(type = as.character(umap_pbmc_scaled_with_cluster$cluster))

df_model_data_pbmc_n <- bind_rows(df_b_pbmc, data_pbmc_n)

langevitour::langevitour(df_model_data_pbmc_n[1:(length(df_model_data_pbmc_n)-1)],
                         lineFrom = tr_from_to_df_pbmc$from,
                         lineTo = tr_from_to_df_pbmc$to,
                         group = factor(df_model_data_pbmc_n$type,
                                        c("cluster1", "cluster2", "cluster3", "model")),
                         levelColors = c("#8dd3c7", "#fdb462", "#bebada", "#000000"))
```

```{r}
#| label: pbmc-umap-model-proj

## First projection
projection <- cbind(
    c(-0.4545,-0.5533,-0.1235,0.3984,-0.2065,-0.3586,-0.0088,0.3572,-0.1368),
    c(0.4576,-0.3157,0.4708,0.1410,-0.4479,-0.1685,0.3668,-0.2692,0.1332))

proj_obj1 <- get_projection(projection = projection, 
               proj_scale = 1.23, 
               highd_data = scaled_pbmc_data, 
               model_highd = scaled_pbmc_data_model, 
               trimesh_data = tr_from_to_df_pbmc, 
               axis_param = list(limits = 1,
                                 axis_scaled = 1, 
                                 axis_pos_x = -0.48, 
                                 axis_pos_y = -0.48, 
                                 threshold = 0.082))

proj_obj1[["cluster"]] <- as.character(umap_pbmc_scaled_with_cluster$cluster)

pbmc_proj_umap_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.65, 0.65), 
  axis_text_size = 4,
  is_category = TRUE) + 
  interior_annotation(label = "a2", cex = 2) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada"))

## Second projection
projection <- cbind(
    c(0.0734,0.6138,-0.4671,0.2589,0.1189,0.0778,-0.0819,0.0308,-0.5561),
    c(0.6625,0.0034,0.2412,0.3360,0.2463,0.1070,-0.2903,-0.4705,0.1293))

proj_obj2 <- get_projection(projection = projection, 
               proj_scale = 1.25, 
               highd_data = scaled_pbmc_data, 
               model_highd = scaled_pbmc_data_model, 
               trimesh_data = tr_from_to_df_pbmc, 
               axis_param = list(limits = 1.35, 
                                 axis_scaled = 1, 
                                 axis_pos_x = -0.75, 
                                 axis_pos_y = -0.75, 
                                 threshold = 0.12))

proj_obj2[["cluster"]] <- as.character(umap_pbmc_scaled_with_cluster$cluster)

pbmc_proj_umap_model2 <- plot_proj(
    proj_obj = proj_obj2, 
    point_param = c(1.5, 0.2), # size, alpha, color
    plot_limits = c(-1, 0.75), 
    axis_text_size = 4,
    is_category = TRUE) +
  interior_annotation(label = "a3", cex = 2) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada"))

```

```{r}
#| label: hexbin-pbmc2

## Compute hexbin parameters
num_bins_x_pbmc <- 30

algo_obj_pbmc <- fit_highd_model(
  highd_data = training_data_pbmc, 
  nldr_data = tsne_pbmc, 
  bin1 = num_bins_x_pbmc, 
  q = 0.1, 
  benchmark_highdens = 1)

tsne_pbmc_scaled <- algo_obj_pbmc$nldr_obj$scaled_nldr
tr_from_to_df_pbmc <- algo_obj_pbmc$trimesh_data
df_bin_centroids_pbmc <- algo_obj_pbmc$model_2d
df_bin_pbmc <- algo_obj_pbmc$model_highd

tsne_pbmc_scaled_with_cluster <- tsne_pbmc_scaled |>
  mutate(cluster = if_else((emb2 <= -emb1 + 0.8) & (emb1 < 0.5), "cluster1", if_else(emb2 >= -2 * emb1 + 1.79, "cluster3", "cluster2"))) |>
  mutate(cluster = factor(cluster, levels = c("cluster1", "cluster2", "cluster3")))

trimesh_removed_pbmc_best <- ggplot() + 
  geom_point(
    data = tsne_pbmc_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.2,
    size = 0.1
  )  +
  geom_segment(data = tr_from_to_df_pbmc, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada")) +
  interior_annotation("b1", cex = 2) +
  theme(
    aspect.ratio = 1
  )
```

```{r}
#| label: prep-pbmc-tsne-model-proj-best

data_pbmc <- training_data_pbmc |> 
  select(-ID) |>
  mutate(type = "data")

df_b_pbmc <- df_bin_pbmc |>
  dplyr::filter(hexID %in% df_bin_centroids_pbmc$hexID) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the hexID order in df_b_with_center_data
df_b_pbmc <- df_b_pbmc[match(df_bin_centroids_pbmc$hexID, df_b_pbmc$hexID),] |>
  dplyr::select(-hexID) 

# Apply the scaling
df_model_data_pbmc <- bind_rows(data_pbmc, df_b_pbmc)
scaled_pbmc <- scale_data_manual(df_model_data_pbmc, "type") |>
  as_tibble()

scaled_pbmc_data <- scaled_pbmc |>
  filter(type == "data") |>
  select(-type)

scaled_pbmc_data_model <- scaled_pbmc |>
  filter(type == "model") |>
  select(-type)
```

```{r}
#| label: langevitour-pbmc-tsne-author-proj-best
#| eval: false

data_pbmc_n <- data_pbmc |>
  select(-type) |>
  mutate(type = as.character(tsne_pbmc_scaled_with_cluster$cluster))

df_model_data_pbmc_n <- bind_rows(df_b_pbmc, data_pbmc_n)

langevitour::langevitour(df_model_data_pbmc_n[1:(length(df_model_data_pbmc_n)-1)],
                         lineFrom = tr_from_to_df_pbmc$from,
                         lineTo = tr_from_to_df_pbmc$to,
                         group = factor(df_model_data_pbmc_n$type,
                                        c("cluster1", "cluster2", "cluster3", "model")),
                         levelColors = c("#8dd3c7", "#fdb462", "#bebada", "#000000"))
```

```{r}
#| label: pbmc-tsne-model-proj-best

## First projection
projection <- cbind(
  c(-0.4545,-0.5533,-0.1235,0.3984,-0.2065,-0.3586,-0.0088,0.3572,-0.1368),
  c(0.4576,-0.3157,0.4708,0.1410,-0.4479,-0.1685,0.3668,-0.2692,0.1332))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_pbmc_data, 
                            model_highd = scaled_pbmc_data_model, 
                            trimesh_data = tr_from_to_df_pbmc, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 1, 
                                              axis_pos_x = -0.48, 
                                              axis_pos_y = -0.48, 
                                              threshold = 0.082))

proj_obj1[["cluster"]] <- as.character(tsne_pbmc_scaled_with_cluster$cluster)

pbmc_proj_tsne_model1_best <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.65, 0.65), 
  axis_text_size = 4,
  is_category = TRUE) + 
  interior_annotation(label = "b2", cex = 2) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada"))

## Second projection
projection <- cbind(
  c(0.0734,0.6138,-0.4671,0.2589,0.1189,0.0778,-0.0819,0.0308,-0.5561),
  c(0.6625,0.0034,0.2412,0.3360,0.2463,0.1070,-0.2903,-0.4705,0.1293))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.25, 
                            highd_data = scaled_pbmc_data, 
                            model_highd = scaled_pbmc_data_model, 
                            trimesh_data = tr_from_to_df_pbmc, 
                            axis_param = list(limits = 1.35, 
                                              axis_scaled = 1, 
                                              axis_pos_x = -0.75, 
                                              axis_pos_y = -0.75, 
                                              threshold = 0.12))

proj_obj2[["cluster"]] <- as.character(tsne_pbmc_scaled_with_cluster$cluster)

pbmc_proj_tsne_model2_best <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1, 0.75), 
  axis_text_size = 4,
  is_category = TRUE) + 
  interior_annotation(label = "b3", cex = 2) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada"))

```

```{r}
#| echo: false
#| fig-cap: "Compare the published \\gD{} layout (@fig-pbmc-mse-umap a) and the \\gD{} layout selected (@fig-pbmc-mse-umap b) by MSE plot (@fig-pbmc-mse-umap) from tSNE and UMAP with default hyper-parameters. The PBMC3k data ($n =  5858$) has three clusters in $9\\text{-}D$, where three clusters are close. Two \\gD{} projection from a tour on $9\\text{-}D$ of the model fit with @fig-pbmc-mse-umap a ($a_1 = 0.06$, $b = 616/86 (22, 28)$) shows three-well separated clusters with big separations. On the other hand, the model fit with @fig-pbmc-mse-umap b ($a_1 = 0.06$, $b = 704/227 (22, 32)$) shows three-well separated clusters with small separations. Therefore, @fig-pbmc-mse-umap b is more reasonable than @fig-pbmc-mse-umap a. Videos of the langevitour animations are available at <https://youtu.be/0cKX_HG_n0k> and <https://youtu.be/KhJvsRtaX04> respectively."
#| label: fig-model-pbmc-author-proj
#| fig-pos: H
#| fig-width: 10
#| fig-height: 15
#| out-width: 90%

free(trimesh_removed_pbmc) + free(trimesh_removed_pbmc_best) +
  pbmc_proj_umap_model1 + pbmc_proj_tsne_model1_best +
  pbmc_proj_umap_model2 + pbmc_proj_tsne_model2_best +
  plot_layout(nrow=2, byrow=FALSE) &
  theme(legend.position='none')
```

