---
title: "Appendix: Looking at Non-Linear Dimension Reductions as Models in the Data Space"
format: 
    jasa-pdf:
        keep-tex: true
    jasa-html: default
author:
  - name: Jayani P.G. Lakshika
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-6265-6481
    email: jayani.piyadigamage@monash.edu
    url: https://jayanilakshika.netlify.app/
  - name: Dianne Cook
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-3813-7155
    email: dicook@monash.edu 
    url: http://www.dicook.org/
  - name: Paul Harrison
    affiliations:
      - name: Monash University
        department: MGBP, BDInstitute
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-3980-268X
    email: 	paul.harrison@monash.edu
    url: 
  - name: Michael Lydeamore
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0001-6515-827X
    email: michael.lydeamore@monash.edu
    url: https://www.michaellydeamore.com/
  - name: Thiyanga S. Talagala
    affiliations:
      - name: University of Sri Jayewardenepura
        department: Statistics
        address: Gangodawila
        city: Nugegoda 
        country: Sri Lanka
        postal-code: 10100
    orcid: 0000-0002-0656-9789
    email: ttalagala@sjp.ac.lk 
    url: https://thiyanga.netlify.app/
tbl-cap-location: bottom
header-includes: | 
  \usepackage{amsmath}
  \usepackage{float}
  \usepackage{hyperref}
  \usepackage[utf8]{inputenc}
  \usepackage{bm}
  \def\tightlist{}
  \usepackage{setspace}
  \newcommand\pD{$p\text{-}D$}
  \newcommand\kD{$k\text{-}D$}
  \newcommand\dD{$d\text{-}D$}
  \newcommand\gD{$2\text{-}D$}
  \newcommand{\To}{\textbf{to}~}
  \usepackage{abstract}
  \renewcommand{\abstractname}{}    % clear the title
  \renewcommand{\absnamepos}{empty} % originally center
---

```{r include=FALSE}
# Set up chunk for for knitr
knitr::opts_chunk$set(
  fig.width = 5,
  fig.height = 5,
  fig.align = "center",
  out.width = "100%",
  code.line.numbers = FALSE,
  fig.retina = 4,
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  dev.args = list(pointsize = 11)
)
```

```{r}
library(ggplot2)
library(dplyr)
library(quollr)
library(readr)
library(ggforce)
library(patchwork)
library(kableExtra)

theme_set(theme_linedraw() +
   theme(
     #aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "none", 
     legend.title = element_text(size=5), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm')
   )
)
```

```{r}
#| label: tbl-notation
#| tbl-cap: "Summary of notation for describing new methodology."
# Notation used in the paper

notation_df <- read_csv("misc/notation.csv")

# Create the table
kable(notation_df, 
      format = "latex", 
      booktabs = TRUE, escape = FALSE) |>
  kable_styling(position = "center", 
                full_width = FALSE, 
                font_size = 12) |>
  row_spec(0, bold = TRUE) |>
  column_spec(1:2, width = c("3cm", "12cm"))
```

## Computing hexagon grid configurations

Given range of embedding component, $r_2$, number of bins along the x-axis, $b_1$, and buffer proportion, $q$, hexagonal starting point coordinates, $s_1 = -q$, and $s_2 = -q \times r_2$. The purpose is to find width of the hexagon. $a_1$, and number of bins along the y-axis, $b_2$.

```{r}
umap_scurve <- read_rds(file = here::here("data/s_curve/s_curve_umap.rds")) 

scurve_scaled_obj <- gen_scaled_data(
  data = umap_scurve)

umap_scurve_scaled <- scurve_scaled_obj$scaled_nldr
lim1 <- scurve_scaled_obj$lim1
lim2 <- scurve_scaled_obj$lim2
r2 <- diff(lim2)/diff(lim1)

sc_ltr_pos <- c(0.08, 0.96)
sc_xlims <- c(-0.5, 1.47)
sc_ylims <- c(-0.32, 2.1)
```

<!--Full hexagon grid with UMAP data-->

```{r}
## Compute hexbin parameters
num_bins_x_scurve <- 7

## hexagon binning to have regular hexagons
hb_obj_scurve <- hex_binning(
  data = umap_scurve_scaled, 
  bin1 = num_bins_x_scurve, 
  r2 = r2)

## Data set with all centroids
all_centroids_df <- hb_obj_scurve$centroids

## Generate all coordinates of hexagons
hex_grid <- hb_obj_scurve$hex_poly
```

```{r}
# Code to draw illustration for notation
start_pt <- all_centroids_df |> 
  filter(hexID == 1)
d_rect <- tibble(x1min = 0, 
                 x1max = 1,
                 x2min = 0,
                 x2max = r2)

c_start <- tibble(s1 = 0.03, s2 = -0.05)

a1 <- tibble(x = all_centroids_df$c_x[4],
             xend = all_centroids_df$c_x[5],
             y = all_centroids_df$c_y[21],
             yend = all_centroids_df$c_y[21],
             label = expression(a[1]))
a2 <- tibble(x = all_centroids_df$c_x[27],
             xend = all_centroids_df$c_x[27],
             y = all_centroids_df$c_y[27],
             yend = all_centroids_df$c_y[33],
             label = expression(a[2]))
hex_param_vis <- ggplot() + 
    geom_polygon(data = hex_grid, 
                        aes(x = x, 
                            y = y, 
                            group = hex_poly_id),
                 fill = "white", 
                 color = "#bdbdbd") +
    geom_point(data = all_centroids_df, aes(
      x = c_x, 
      y = c_y), 
      color = "#31a354", size = 0.9) +
    geom_point(data = start_pt, aes(x = c_x, 
                                    y = c_y), 
               color = "black") + 
    geom_rect(data=d_rect, 
              aes(xmin = x1min - c_start$s1,# - c_start$s1, 
                  xmax = x1max - c_start$s1,# - c_start$s1, 
                  ymin = x2min - c_start$s2,# - c_start$s2, 
                  ymax = x2max - c_start$s2),# - c_start$s2), 
              fill = "white", 
              color = "black", 
              alpha = 0, 
              linewidth = 0.7) +
    geom_point(data=d_rect, aes(x=x1min - c_start$s1, 
                                y=x2min - c_start$s2)) + 
    geom_point(data=d_rect, aes(x=x1max - c_start$s1, 
                                y=x2min - c_start$s2)) + 
    geom_point(data=d_rect, aes(x=x1min - c_start$s1, 
                                y=x2max - c_start$s2)) + 
    annotate("text", x=d_rect$x1min - c_start$s1, 
                     y=d_rect$x2min - c_start$s2,
                     label = "(0,0)", 
             hjust=-0.1, vjust=-0.3) + 
    annotate("text", x=d_rect$x1max - c_start$s1, 
                     y=d_rect$x2min - c_start$s2,
                     label = "(0,1)", 
             hjust=1.1, vjust=-0.3) + 
    annotate("text", x=d_rect$x1min - c_start$s1, 
                     y=d_rect$x2max - c_start$s2,
                     label = expression(group("(", 
                        list(0, y[2][max]),")")), 
            hjust=-0.1, vjust=1.2) + 
    geom_segment(data=d_rect, aes(
      x = x1min  - c_start$s1, # 0 - 0.03, 
      y = -0.35, 
      xend = x1max - c_start$s1, #1 - 0.03, 
      yend = -0.35), #-0.35),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
                 color = "black")+
    annotate("text", x=0.5, y=-0.45, 
             label = expression(r[1]), color = "black") +
    geom_segment(data=d_rect, aes(
      x = -0.25, 
      y = x2min - c_start$s2, #0 - 0.05, 
      xend = -0.25, 
      yend = x2max - c_start$s2), #r2 - 0.05),
      arrow = arrow(length = unit(0.03, "npc"),
                       ends = "both"), 
                 color = "black")+ 
    annotate("text", x=-0.35, y=1, 
             label = expression(r[2]), color = "black") +
    geom_segment(data = a1, aes(
      x = x, #-0.1 + 0.2087578, 
      y = y, #-0.15, 
      xend = xend, #-0.1 + 0.2087578*2, 
      yend = yend), #-0.15),
      arrow = arrow(length = unit(0.03, "npc"),
        ends = "both"), 
        color = "black")+ # a1 = 0.2087578
    annotate("text", 
             x=(a1$x+a1$xend)/2, 
             y=a1$y, 
             label = expression(a[1]), 
             color = "black",
             vjust = 1.2) +
    geom_segment(data = a2, aes(
      x = x, #-0.15, 
      y = y, #-0.1*r2 + 0.1807896*2, 
      xend = xend, #-0.15, 
      yend = yend), #-0.1*r2 + 0.1807896*3),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
      color = "black") + # a2 = 0.1807896
    annotate("text", x=a2$x, y=(a2$y+a2$yend)/2, 
             label = expression(a[2]), 
             color = "black", hjust=-0.2) +
    annotate("text", x=-0.18, y=-0.25, 
      label = expression(group("(", list(s[1], s[2]), ")")),
      color = "black") 
```

```{r}
#| label: fig-hex-param
#| fig-cap: "The components of the hexagon grid illustrating notation."
#| out-height: 30%
#| fig-width: 2.5
#| fig-height: 3.3
#| fig-pos: H

hex_param_vis
```

Geometric arguments give rise to the following constraints.

$\text{min }a_1 \text{ s.t.}$

$$
s_1 - \frac{a_1}{2} < 0,
$$ {#eq-equation1}

$$
s_1 + (b_1 - 1) \times a_1 > 1,
$$ {#eq-equation2}

$$
s_2 - \frac{a_2}{2} < 0,
$$ {#eq-equation4}

$$
s_2 + (b_2 - 1) \times a_2 > r_2.
$$ {#eq-equation5}

Since $a_1$ and $a_2$ are distances,

$$
a_1, a_2 > 0.
$$ Also, $(s_1, s_2) \in (-0.1, -0.05)$ as these are multiplicative offsets in the negative direction.

@eq-equation1 can be rearranged as,

$$
a_1 > 2s_1
$$

which given $s_1 < 0$ and $a_1 > 0$ will *always* be true. The same logic follows for @eq-equation4 and substituting $a_2 = \frac{\sqrt{3}}{2}a_1$, and $s_2 = -q \times r_2$ to @eq-equation4 can be written as,

$$
a_1 > -\frac{4}{\sqrt{3}}qr_2
$$

Also, substituting $a_2 = \frac{\sqrt{3}}{2}a_1$, $s_2 = -q \times r_2$ and rearranging @eq-equation5 gives:

$$
a_1 > \frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)}.
$$ {#eq-equation6}

Similarly, substituting $s_1 = -q$ @eq-equation2 becomes,

$$
a_1 > \frac{(1 + q)}{(b_1 - 1)}.
$$ {#eq-equation7}

This is a linear optimization problem. Therefore, the optimal solution must occur on a vertex. So, by setting @eq-equation6 equals to @eq-equation7 gives,

$$
\frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)} = \frac{(1 + q)}{(b_1 - 1)}.
$$ After rearranging this,

$$
b_2 = 1 + \frac{2r_2(b_1 - 1)}{\sqrt{3}}
$$

and since $b_2$ should be an integer,

$$
b_2 = \Big\lceil1 +\frac{2r_2(b_1 - 1)}{\sqrt{3}}\Big\rceil.
$$ {#eq-equation8}

Furthermore, with known $b_1$ and $b_2$, by considering @eq-equation2 or @eq-equation5 as the *binding* or *active constraint*, can compute $a_1$.

If @eq-equation2 is active, then,

$$
\frac{(1 + q)}{(b_1 - 1)} < \frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)}.
$$

Rearranging this gives,

$$
r_2 > \frac{\sqrt{3}(b_2 - 1)}{2(b_1 - 1)}.
$$

Therefore, if this equality is true, then $a_1 = \frac{(1+q)}{(b_1 - 1)}$, otherwise, $a_1 = \frac{2r_2(1+q)}{\sqrt{3}(b_2 - 1)}$.

\newpage

## Binning the data

Points are assigned to the bin they fall into based on the nearest centroid. If a point is equidistant from multiple centroids, it is assigned to the centroid with the lowest hexagonal bin ID.

```{r}
all_centroids_df <- gen_centroids(bin1 = 4, r2 = r2, q = 0.1)

hex_grid <- gen_hex_coord(all_centroids_df, a1 = 1.043789)

## Data to generate circle
circles <- data.frame(
  x = c(0.422, 0.683),
  y = c(0.740, 1.19),
  r = rep(0.301316, 2)
)

emb_df1 <- tibble(emb1 = 0.58, emb2 = 0.93) |>
  add_row(emb1 = 0.5, emb2 = 1.01)

assign_data_vis1 <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_point(data = emb_df1, aes(x = emb1, y = emb2), color = "black", size = 0.7) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 5, colour = "#bdbdbd") +
  geom_circle(data = circles, aes(x0 = x, y0 = y, r = r), fill = NA) +
  geom_segment(x = 0.58, y = 0.93, xend = 0.44, yend = 0.76, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#969696") +
  geom_segment(x = 0.5, y = 1.01, xend = 0.68, yend = 1.16, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#969696")

emb_df2 <- tibble(emb1 = 0.161, emb2 = 0.7395) |>
  add_row(emb1 = 0.683, emb2 = 0.7395) |>
  add_row(emb1 = 0.2915, emb2 = 0.965) |>
  add_row(emb1 = 0.5525, emb2 = 0.965) |>
  add_row(emb1 = 0.2915, emb2 = 0.5135) |>
  add_row(emb1 = 0.5525, emb2 = 0.5135) |>
  add_row(emb1 = 0.422, emb2 = 1.04) |>
  add_row(emb1 = 0.161, emb2 = 0.890) |>
  add_row(emb1 = 0.161, emb2 = 0.589) |>
  add_row(emb1 = 0.422, emb2 = 0.438) |>
  add_row(emb1 = 0.683, emb2 = 0.589) |>
  add_row(emb1 = 0.683, emb2 = 0.890)

assign_data_vis2 <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_point(data = emb_df2, aes(x = emb1, y = emb2), color = "black", size = 0.7) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 5, colour = "#bdbdbd") +
  geom_segment(x = 0.161, y = 0.7395, xend = -0.06, yend = 0.740, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.683, y = 0.7395, xend = 0.45, yend = 0.740, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.2915, y = 0.965, xend = 0.43, yend = 0.79, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.5525, y = 0.965, xend = 0.44, yend = 0.8, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.2915, y = 0.5135, xend = 0.18, yend = 0.32, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.5525, y = 0.5135, xend = 0.67, yend = 0.32, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.422, y = 1.04, xend = 0.42, yend = 0.85, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.161, y = 0.890, xend = -0.02, yend = 0.8, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.161, y = 0.589, xend = 0.161, yend = 0.4, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.422, y = 0.438, xend = 0.25, yend = 0.3, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.683, y = 0.589, xend = 0.683, yend = 0.4, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") +
  geom_segment(x = 0.683, y = 0.890, xend = 0.5, yend = 0.82, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd")  
  
```

```{r}
#| label: fig-assign-data
#| fig-cap: "Binning the data. Points are assigned to the nearest centroid. If a point is equidistant from multiple centroids, assigned to the lowest centroid."
#| fig-width: 9
#| fig-height: 6
assign_data_vis1 + assign_data_vis2 +
  plot_layout(ncol = 2)
```

\newpage

## Area of a hexagon

The area of a hexagon is defined as $A = \frac{3\sqrt{3}}{2}l^2$, where $l$ is the side length of the hexagon. $l$ can be computed using $a_1$ and $a_2$.


```{r}
# triangle_temp <- tibble(
#   x = c(0, 4, 0),
#   y = c(0, 0, 3)
# )

triangle_line_temp <- tibble(
  x = c(4, 0, 4),
  xend = c(0, 0, 0),
  y = c(0, 0, 0),
  yend = c(0, 3, 3)
)

triangle_arrow_temp <- tibble(
  x = c(4 + 0.04, 0 - 0.06, 4 + 0.06),
  xend = c(0 + 0.04, 0 - 0.06, 0 + 0.06),
  y = c(0 - 0.04, 0 - 0.06, 0 + 0.06),
  yend = c(0 - 0.04, 3 - 0.06, 3 + 0.06)
)

triangle_plot <- ggplot() +
  # geom_point(
  #   data = triangle_temp,
  #   aes(
  #     x = x,
  #     y = y
  #   )
  # ) +
  geom_segment(
    data = triangle_line_temp,
    aes(
      x = x,
      xend = xend,
      y = y,
      yend = yend
    )
  ) + 
  annotate("text", x=-1, y= 1.5, 
           label = expression(frac(a[2] - a[1], 2)), 
           color = "black", hjust=-0.2) + 
  annotate("text", x=1.5, y= -0.3, 
           label = expression(frac(a[1], 2)), 
           color = "black", hjust=-0.2) + 
  annotate("text", x=2.5, y= 1.5, 
           label = expression(l), 
           color = "black", hjust=-0.2)
```

```{r}
#| label: fig-tri-param
#| fig-cap: "The components of the right triangle illustrating notation."
#| out-height: 30%

triangle_plot
```

By applying the Pythagorean theorem, we obtain,

$$
l^2 = \left(\frac{a_1}{2}\right)^2 + \left(\frac{a_2 - l}{2}\right)^2.
$$
Next, rearranging the terms, we get,

$$
l^2 - \left(\frac{a_2 - l}{2}\right)^2 = \left(\frac{a_1}{2}\right)^2,
$$

$$
\left[l - \left(\frac{a_2 - l}{2}\right)\right]\left[l + \left(\frac{a_2 - l}{2}\right)\right] = \left(\frac{a_1}{2}\right)^2,
$$

$$
3l^2 + 2a_2l - (a_1^2 + a_2^2) = 0.
$$

Finally, by solving the quadratic equation, we compute,

$$
l = \frac{-2a_2 \pm \sqrt{4a_2^2 - 24[-(a_1^2 + a_2^2)]}}{6},
$$

$$
l = \frac{-a_2 \pm \sqrt{a_2^2 - 6[-(a_1^2 + a_2^2)]}}{3},
$$

where $l > 0$.
