---
title: "Appendix: Looking at Non-Linear Dimension Reductions as Models in the Data Space"
format: 
    jasa-pdf:
        keep-tex: true
    jasa-html: default
author:
  - name: Jayani P. Gamage
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-6265-6481
    email: jayani.piyadigamage@monash.edu
    url: https://jayanilakshika.netlify.app/
  - name: Dianne Cook
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-3813-7155
    email: dicook@monash.edu 
    url: http://www.dicook.org/
  - name: Paul Harrison
    affiliations:
      - name: Monash University
        department: MGBP, BDInstitute
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0002-3980-268X
    email: 	paul.harrison@monash.edu
    url: 
  - name: Michael Lydeamore
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Australia
        postal-code: 3800
    orcid: 0000-0001-6515-827X
    email: michael.lydeamore@monash.edu
    url: https://www.michaellydeamore.com/
  - name: Thiyanga S. Talagala
    affiliations:
      - name: University of Sri Jayewardenepura
        department: Statistics
        address: Gangodawila
        city: Nugegoda 
        country: Sri Lanka
        postal-code: 10100
    orcid: 0000-0002-0656-9789
    email: ttalagala@sjp.ac.lk 
    url: https://thiyanga.netlify.app/
tbl-cap-location: bottom
bibliography: paper.bib 
header-includes: | 
  \usepackage{amsmath}
  \usepackage{float}
  \usepackage{hyperref}
  \usepackage[utf8]{inputenc}
  \usepackage{bm}
  \def\tightlist{}
  \usepackage{setspace}
  \newcommand\pD{$p\text{-}D$}
  \newcommand\kD{$k\text{-}D$}
  \newcommand\dD{$d\text{-}D$}
  \newcommand\gD{$2\text{-}D$}
  \newcommand{\To}{\textbf{to}~}
  \usepackage{abstract}
  \renewcommand{\abstractname}{}    % clear the title
  \renewcommand{\absnamepos}{empty} % originally center
---

```{r include=FALSE}
# Set up chunk for for knitr
knitr::opts_chunk$set(
  fig.width = 5,
  fig.height = 5,
  fig.align = "center",
  out.width = "100%",
  code.line.numbers = FALSE,
  fig.retina = 4,
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  dev.args = list(pointsize = 11)
)
```

```{r include=FALSE}
#| label: install-libraries
#| warning: false
#| echo: false

options(repos = c(CRAN = "https://cran.rstudio.com")) # Setup mirror

packages_to_check <- c("remotes", "tidyverse", "patchwork", "colorspace", "kableExtra", "conflicted", "ggforce")

for (pkg in packages_to_check) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    message(paste("Installing package:", pkg))
    install.packages(pkg)
  } else {
    installed_version <- packageVersion(pkg)
    available_version <- tryCatch({
      utils::packageDescription(pkg)$Version
    }, error = function(e) NA) # Handle cases where package info isn't readily available

    if (!is.na(available_version) && installed_version < package_version(available_version)) {
      message(paste("A newer version of package", pkg, "is available. Updating..."))
      install.packages(pkg)
    } else {
      message(paste("Package", pkg, "is up-to-date (version", installed_version, ")."))
    }
  }
}

```

```{r}
#| label: load-libraries
#| warning: false
#| echo: false
library(tibble)
library(dplyr)
library(ggplot2)
library(readr)
library(tidyr)
library(patchwork)
library(colorspace)
library(kableExtra)
library(conflicted)
library(ggforce)

conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
```

```{r}
#| label: plot-theme
theme_set(theme_linedraw() +
   theme(
     #aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "bottom", 
     legend.title = element_blank(), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm'),
     plot.margin = margin(0, 0, 0, 0)
   )
)
```

```{r}
#| label: import-scripts
source("scripts/additional_functions.R")
```

```{r}
#| label: code-setup
set.seed(20240110)
```

```{r}
clr_choice <- "#0077A3"
```

```{r}
#| label: tbl-notation
#| tbl-cap: "Summary of notation for describing new methodology."
# Notation used in the paper

notation_df <- read_csv("misc/notation.csv")

# Create the table
kable(notation_df, 
      format = "latex", 
      booktabs = TRUE, escape = FALSE, linesep = "") |>
  kable_styling(position = "center", 
                full_width = FALSE, 
                font_size = 12) |>
  row_spec(0, bold = TRUE) |>
  column_spec(1:2, width = c("3cm", "12cm"))
```

## Generating the nonlinear clusters data

```{r}
proj_obj1_true <- read_rds("data/two_nonlinear/two_nonlinear_true_proj_obj1.rds")

two_curvy_proj_true1 <- plot_proj(
  proj_obj = proj_obj1_true,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  line_param = c(0.5, 0.5, "#000000"), # linewidth, alpha
  plot_limits = c(-0.75, 0.75),
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a", cex = 1.2) +
  theme(aspect.ratio = 1,
        legend.position = "none")

proj_obj2_true <- read_rds("data/two_nonlinear/two_nonlinear_true_proj_obj2.rds")

two_curvy_proj_true2 <- plot_proj(
  proj_obj = proj_obj2_true,
  point_param = c(0.1, 0.5, clr_choice), # size, alpha, color
  line_param = c(0.5, 0.5, "black"), # linewidth, alpha
  plot_limits = c(-0.5, 0.5),
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "b", cex = 1.2) +
  theme(aspect.ratio = 1)
```

```{r}
#| fig-width: 6
#| fig-height: 3
#| fig-cap: "Two projections of the \\pD{} true model overlaying the data are shown in a, b."

two_curvy_proj_true1 + two_curvy_proj_true2
```

## Computing hexagon grid configurations

Given range of embedding component, $r_2$, number of bins along the x-axis, $b_1$, and buffer proportion, $q$, hexagonal starting point coordinates, $s_1 = \text{-}q$, and $s_2 = \text{-}qr_2$. The purpose is to find width of the hexagon. $a_1$, and number of bins along the y-axis, $b_2$.

Geometric arguments give rise to the following constraints.

$\text{min }a_1 \text{ s.t.}$

$$
s_1 - \frac{a_1}{2} < 0,
$$ {#eq-equation1}

$$
s_1 + (b_1 - 1) \times a_1 > 1,
$$ {#eq-equation2}

$$
s_2 - \frac{a_2}{2} < 0,
$$ {#eq-equation4}

$$
s_2 + (b_2 - 1) \times a_2 > r_2.
$$ {#eq-equation5}




```{r}
#| label: code-illustration
# Code to draw illustration for notation
## hexagon binning to have regular hexagons

hex_grid_temp <- read_rds("data/two_nonlinear/hex_grid_temp.rds")
all_centroids_df_temp <- read_rds("data/two_nonlinear/all_centroids_df_tempp.rds")
start_pt <- read_rds("data/two_nonlinear/start_pt.rds")
d_rect <- read_rds("data/two_nonlinear/d_rect.rds")
a1 <- read_rds("data/two_nonlinear/a2_data.rds")
a2 <- read_rds("data/two_nonlinear/a1_data.rds")
l <- read_rds("data/two_nonlinear/l_data.rds")
rect_adj <- read_rds("data/two_nonlinear/rect_adj.rds")

hex_param_vis <- ggplot() + 
    geom_polygon(data = hex_grid_temp, 
                        aes(x = x, 
                            y = y, 
                            group = hex_poly_id),
                 fill = "white", 
                 colour = "#bdbdbd") +
    geom_point(data = all_centroids_df_temp, aes(
      x = c_x, 
      y = c_y), 
      colour = "#31a354", size = 0.9) +
    geom_point(data = start_pt, aes(x = c_x, 
                                    y = c_y), 
               colour = "black") + 
    geom_rect(data=d_rect, 
              aes(xmin = x1min - rect_adj$x1,# - rect_adj$s1, 
                  xmax = x1max - rect_adj$x1,# - rect_adj$s1, 
                  ymin = x2min - rect_adj$x2,# - rect_adj$s2, 
                  ymax = x2max - rect_adj$x2),# - rect_adj$s2), 
              fill = "white", 
              colour = "black", 
              alpha = 0, 
              linewidth = 0.7) +
    geom_point(data=d_rect, aes(x=x1min - rect_adj$x1, 
                                y=x2min - rect_adj$x2)) + 
    geom_point(data=d_rect, aes(x=x1max - rect_adj$x1, 
                                y=x2min - rect_adj$x2)) + 
    geom_point(data=d_rect, aes(x=x1min - rect_adj$x1, 
                                y=x2max - rect_adj$x2)) + 
    annotate("text", x=d_rect$x1min - rect_adj$x1, 
                     y=d_rect$x2min - rect_adj$x2,
                     label = "(0,0)", 
             hjust=-0.1, vjust=-0.3, size = 8) + 
    annotate("text", x=d_rect$x1max - rect_adj$x1, 
                     y=d_rect$x2min - rect_adj$x2,
                     label = "(0,1)", 
             hjust=1.1, vjust=-0.3, size = 8) + 
    annotate("text", x=d_rect$x1min - rect_adj$x1, 
                     y=d_rect$x2max - rect_adj$x2,
                     label = expression(group("(", 
                        list(0, y[2][max]),")")), 
            hjust=-0.1, vjust=1.2, size = 8) + 
    geom_segment(data=d_rect, aes(
      x = x1min  - rect_adj$x1, # 0 - 0.03, 
      y = -0.31, 
      xend = x1max - rect_adj$x1, #1 - 0.03, 
      yend = -0.31), #-0.35),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
                 colour = "black")+
    annotate("text", x=0.5, y=-0.36, 
             label = expression(r[1]), colour = "black", size = 8) +
    geom_segment(data=d_rect, aes(
      x = -0.25, 
      y = x2min - rect_adj$x2, #0 - 0.05, 
      xend = -0.25, 
      yend = x2max - rect_adj$x2), #r2 - 0.05),
      arrow = arrow(length = unit(0.03, "npc"),
                       ends = "both"), 
                 colour = "black")+ 
    annotate("text", x=-0.3, y=0.4, 
             label = expression(r[2]), colour = "black", size = 8) +
    geom_segment(data = a1, aes(
      x = x, #-0.1 + 0.2087578, 
      y = y, #-0.15, 
      xend = xend, #-0.1 + 0.2087578*2, 
      yend = yend), #-0.15),
      arrow = arrow(length = unit(0.03, "npc"),
        ends = "both"), 
        colour = "black")+ # a1 = 0.2087578
    annotate("text", 
             x=(a1$x+a1$xend)/2, 
             y=a1$y, 
             label = expression(a[1]), 
             colour = "black",
             vjust = 1.2, size = 8) +
    geom_segment(data = a2, aes(
      x = x, #-0.15, 
      y = y, #-0.1*r2 + 0.1807896*2, 
      xend = xend, #-0.15, 
      yend = yend), #-0.1*r2 + 0.1807896*3),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
      colour = "black") + # a2 = 0.1807896
    annotate("text", x=a2$x, y=(a2$y+a2$yend)/2, 
             label = expression(a[2]), 
             colour = "black", hjust=-0.2, size = 8) +
    annotate("text", x=-0.18, y=-0.24, 
      label = expression(group("(", list(s[1], s[2]), ")")),
      colour = "black", size = 8) +
  geom_segment(data = l, aes(
      x = x, #-0.15, 
      y = y, #-0.1*r2 + 0.1807896*2, 
      xend = xend, #-0.15, 
      yend = yend), #-0.1*r2 + 0.1807896*3),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
      colour = "black") + 
    annotate("text", x=l$x + 0.03, y=(l$y+l$yend)/2, 
             label = expression(l), 
             colour = "black", hjust=-0.2, size = 8) +
  coord_equal()
```

```{r}
#| label: fig-hex-param
#| fig-cap: "The components of the hexagon grid illustrating notation."
#| out-width: 30%
#| fig-pos: H
#| eval: false

hex_param_vis
```

Since $a_1$ and $a_2$ are distances,

$$
a_1, a_2 > 0.
$$ Also, $(s_1, s_2) \in (\text{-}0.1, \text{-}0.05)$ as these are multiplicative offsets in the negative direction.

@eq-equation1 can be rearranged as,

$$
a_1 > 2s_1
$$

which given $s_1 < 0$ and $a_1 > 0$ will *always* be true. The same logic follows for @eq-equation4 and substituting $a_2 = \sqrt{3}a_1/{2}$, and $s_2 = \text{-}qr_2$ to @eq-equation4 can be written as,

$$
a_1 > -\frac{4}{\sqrt{3}}qr_2
$$

Also, substituting $a_2 = \sqrt{3}a_1/{2}$, $s_2 = \text{-}qr_2$ and rearranging @eq-equation5 gives:

$$
a_1 > \frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)}.
$$ {#eq-equation6}

Similarly, substituting $s_1 = \text{-}q$ @eq-equation2 becomes,

$$
a_1 > \frac{(1 + q)}{(b_1 - 1)}.
$$ {#eq-equation7}

This is a linear optimization problem. Therefore, the optimal solution must occur on a vertex. So, by setting @eq-equation6 equals to @eq-equation7 gives,

$$
\frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)} = \frac{(1 + q)}{(b_1 - 1)}.
$$ 

After rearranging this,

$$
b_2 = 1 + \frac{2r_2(b_1 - 1)}{\sqrt{3}}
$$

and since $b_2$ should be an integer,

$$
b_2 = \Big\lceil1 +\frac{2r_2(b_1 - 1)}{\sqrt{3}}\Big\rceil.
$$ {#eq-equation8}

Furthermore, with known $b_1$ and $b_2$, by considering @eq-equation2 or @eq-equation5 as the *binding* or *active constraint*, can compute $a_1$.

If @eq-equation2 is active, then,

$$
\frac{(1 + q)}{(b_1 - 1)} < \frac{2(r_2 + qr_2)}{\sqrt{3}(b_2 - 1)}.
$$

Rearranging this gives,

$$
r_2 > \frac{\sqrt{3}(b_2 - 1)}{2(b_1 - 1)}.
$$

Therefore, if this equality is true, then 
$$
a_1 = \frac{(1+q)}{(b_1 - 1)},
$$
otherwise, 
$$
a_1 = \frac{2r_2(1+q)}{\sqrt{3}(b_2 - 1)}.
$$

## Binning the data

Points are assigned to the bin they fall into based on the nearest centroid. If a point is equidistant from multiple centroids, it is assigned to the centroid with the smallest bin ID.

```{r}

## Data set with all centroids
all_centroids_df <- read_rds("data/two_nonlinear/two_nonlinear_all_centroids_two_curvy4.rds")

## Generate all coordinates of hexagons
hex_grid <- read_rds("data/two_nonlinear/two_nonlinear_hex_grid_two_curvy4.rds")

## Data to generate circle
circles <- data.frame(
  x = c(0.608, 0.372),
  y = c(0.306, 0.715),
  r = rep(0.27, 2)
)

emb_df1 <- tibble(emb1 = 0.45, emb2 = 0.47) |>
  add_row(emb1 = 0.54, emb2 = 0.56)

assign_data_vis1 <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_point(data = emb_df1, aes(x = emb1, y = emb2), color = "black", size = 0.7) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 5, colour = "#bdbdbd") +
  geom_circle(data = circles, aes(x0 = x, y0 = y, r = r), fill = NA) +
  geom_segment(x = 0.45, y = 0.47, xend = 0.58, yend = 0.3, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#969696") +
  geom_segment(x = 0.54, y = 0.56, xend = 0.4, yend = 0.715, 
               arrow = arrow(length = unit(0.02, "npc")), color = "#969696")
```

```{r}
hex_data <- hex_grid |> 
  dplyr::filter(hex_poly_id == 8)

# Create all pairs of rows
pairs <- expand_grid(row1 = 1:nrow(hex_data), row2 = 1:nrow(hex_data)) |>
  filter(row1 < row2)

# Compute middle points for each pair of rows
middle_points <- pairs |>
  rowwise() |>
  mutate(
    hex_poly_id = hex_data$hex_poly_id[row1],
    x = (hex_data$x[row1] + hex_data$x[row2]) / 2,
    y = (hex_data$y[row1] + hex_data$y[row2]) / 2
  ) |>
  ungroup() |>
  select(hex_poly_id, x, y) |>
  filter(row_number() %in% c(1, 5, 6, 10, 13, 15))

points_df <- bind_rows(hex_data, middle_points)

arrow_df <- tibble(
  x = points_df$x, 
  y = points_df$y,
  xend = c(0.37, points_df$x[2] - 0.1, 0.136, points_df$x[4] - 0.1, 0.61, points_df$x[6] - 0.1, 0.33, points_df$x[8] - 0.1, 0,  points_df$x[10] - 0.1, 0.58, 0.45),
  yend = c(0.82, points_df$y[2] - 0.1, 0.4, points_df$y[4] - 0.1, 0.4, points_df$y[6] - 0.1, 0.82, points_df$y[8] - 0.1, 0.715, points_df$y[10] - 0.1, 0.4, 0.71)
)

assign_data_vis2 <- ggplot(data = hex_grid, aes(x = x, y = y)) + 
  geom_polygon(fill = "white", color = "#bdbdbd", aes(group = hex_poly_id)) +
  geom_point(data = points_df, aes(x = x, y = y), color = "black", size = 0.7) +
  geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = hexID), size = 5, colour = "#bdbdbd") +
  geom_segment(data = arrow_df, aes(x = x, y = y, xend = xend, yend = yend), 
               arrow = arrow(length = unit(0.02, "npc")), color = "#bdbdbd") 
```

```{r}
#| label: fig-assign-data
#| fig-cap: "Binning the data. Points are assigned to the nearest centroid. If a point is equidistant from multiple centroids, assigned to the centroid with the smallest bin ID."
#| fig-width: 12
#| fig-height: 6
#| fig-pos: H

assign_data_vis1 + assign_data_vis2 +
  plot_layout(ncol = 2)
```

## Area of a hexagon

The area of a hexagon is defined as $A = 3\sqrt{3}l^2/2$, where $l$ is the side length of the hexagon. $l$ can be computed using $a_1$ and $a_2$.


```{r}
# triangle_temp <- tibble(
#   x = c(0, 4, 0),
#   y = c(0, 0, 3)
# )

triangle_line_temp <- tibble(
  x = c(4, 0, 4),
  xend = c(0, 0, 0),
  y = c(0, 0, 0),
  yend = c(0, 3, 3)
)

# triangle_arrow_temp <- tibble(
#   x = c(4 + 0.04, 0 - 0.06, 4 + 0.06),
#   xend = c(0 + 0.04, 0 - 0.06, 0 + 0.06),
#   y = c(0 - 0.04, 0 - 0.06, 0 + 0.06),
#   yend = c(0 - 0.04, 3 - 0.06, 3 + 0.06)
# )

triangle_plot <- ggplot() +
  # geom_point(
  #   data = triangle_temp,
  #   aes(
  #     x = x,
  #     y = y
  #   )
  # ) +
  geom_segment(
    data = triangle_line_temp,
    aes(
      x = x,
      xend = xend,
      y = y,
      yend = yend
    )
  ) + 
  annotate("text", x=-1.5, y= 1.5, 
           label = expression(frac(a[2] - a[1], 2)), 
           color = "black", hjust=-0.2, size = 8) + 
  annotate("text", x=1.5, y= -0.5, 
           label = expression(frac(a[1], 2)), 
           color = "black", hjust=-0.2, size = 8) + 
  annotate("text", x=2.5, y= 1.5, 
           label = expression(l), 
           color = "black", hjust=-0.2, size = 8)
```

```{r}
#| label: fig-tri-param
#| fig-cap: "The components of the right triangle illustrating notation."
#| out-width: 30%
#| fig-pos: H

triangle_plot
```

By applying the Pythagorean theorem, we obtain,

$$
l^2 = \left(\frac{a_1}{2}\right)^2 + \left(\frac{a_2 - l}{2}\right)^2.
$$
Next, rearranging the terms, we get,

$$
l^2 - \left(\frac{a_2 - l}{2}\right)^2 = \left(\frac{a_1}{2}\right)^2,
$$

$$
\left[l - \left(\frac{a_2 - l}{2}\right)\right]\left[l + \left(\frac{a_2 - l}{2}\right)\right] = \left(\frac{a_1}{2}\right)^2,
$$

$$
3l^2 + 2a_2l - (a_1^2 + a_2^2) = 0.
$$

Finally, by solving the quadratic equation, we compute,

$$
l = \frac{-2a_2 \pm \sqrt{4a_2^2 - 24[-(a_1^2 + a_2^2)]}}{6},
$$

$$
l = \frac{-a_2 \pm \sqrt{a_2^2 - 6[-(a_1^2 + a_2^2)]}}{3},
$$

where $l > 0$.

## Single-cell gene expression: comparison with results of scDEED recommendations

<!-- ### Comparison with results of scDEED recommendations -->

<!-- XXX What this section needs: -->

<!-- - connect this with previous section, not make it seem like a completely new. connections are: nldr used to show clustering, scDEED provides a different approach to decide which is best. -->
<!-- - why these two? assume one is the published figure, and second is one recommended by scDEED, which our results confirm is better. -->
<!-- - Refer to figure in text -->
<!-- - Fig 16 not necessary -->

<!-- CHANGES WERE MADE BASED ON THIS THINKING -->



<!-- <!-- In the field of single-cell studies, clustering is a common analytical task used to identify groups of cells with similar expression profiles. Non-linear dimensional reduction (NLDR) methods are frequently employed to visualize these clusters and help validate the results. However, it is well known that the 2D embeddings produced by t-SNE and UMAP may not accurately reflect the similarities among cell clusters. ALREADY STATED IN PREVIOUS SECTION -->  

As we were writing this paper @xia2023 appeared proposing a new method called scDEED helping to assess the validity of a \gD{} embedding. scDEED calculates a reliability score for each cell embedding based on the similarity between the cellâ€™s \gD{} embedding neighbors and its neighbors prior to embedding. A low reliability score suggests a dubious embedding. It can help in the deciding on optimal hyper-parameters. Here we illustrate how our method compares with the results from scDEED.

Note that @xia2023 uses a different subset from the PBMC dataset used by @chen2024, shown by us in the main paper example, which is why this comparison is shown here and not in the main paper. Their data contains $31,021$ cells including cell type labels, and the gene expression levels were in the unit of log-transformed UMI count per $10,000$. They focused on three sequencing methods (inDrops, DropSeq, and SeqWell) and four common cell types Cytotoxic T cell, CD4+T cell, CD14+ Monocyte, and B cell. Pre-processing follows the process in @xia2023 again using the Human Peripheral Blood Mononuclear Cells (PBMC) data. 

For illustration purposes, we only selected cells generated with inDrops ($n=5858$ cells) and UMAP and tSNE cell embeddings. Also, @xia2023 used first $9$ principal components to generate the UMAP and tSNE. The objective is to assess the optimized layout by scDEED, and if it does not accurately represent the three clusters with small separations of the PBMC dataset, then select a reasonable \gD{} layout.

The layout a (@fig-pbmc-mse-umap) is generated from the hyper-parameters suggested by @chen2024, and the layout b (@fig-pbmc-mse-umap) is with suggested hyper-parameters by scDEED to be more accurate. The layout a and b contain $46$ and $83$ dubious cells respectively. 

```{r}
#| label: read-pbmc-umap-layouts
# Read a variety of different NLDR representations of PBMC
# and plot them on same aspect ratio
umap_pbmc <- read_rds("data/pbmc3k/pbmc_scdeed_umap_n_neighbors_30_min_dist_0.3.rds")
umap_pbmc <- as_tibble(umap_pbmc)
names(umap_pbmc) <- c("emb1", "emb2")

nldr1c <- umap_pbmc |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#e41a1c') +
  interior_annotation("a")

tsne_pbmc <- read_rds("data/pbmc3k/pbmc_scdeed_tsne_perplexity_30.rds")
tsne_pbmc <- as_tibble(tsne_pbmc)
names(tsne_pbmc) <- c("emb1", "emb2")

nldr2c <- tsne_pbmc |>
  ggplot(aes(x = emb1,
             y = emb2))+
  geom_point(alpha=0.1, size=1, colour='#377eb8') +
  interior_annotation("b")

```

<!--pbmc3k/11_gen_mse_for_diff_tsne_scDEED.R-->
<!--pbmc3k/11_gen_mse_for_diff_umap_scDEED.R-->
```{r}
#| label: combine-data-pbmc-umap-tsne

error_pbmc_umap <- read_rds("data/pbmc3k/error_scdeed_pbmc_umap_30_min_dist_0.3.rds")
error_pbmc_tsne <- read_rds("data/pbmc3k/error_scdeed_pbmc_tsne_perplexity_30.rds")

error_pbmc <- bind_rows(error_pbmc_umap,
                        error_pbmc_tsne)

error_pbmc <- error_pbmc |>
  mutate(a1 = round(a1, 2)) |>
  filter(bin1 >= 5) |>
  group_by(method, a1) |>
  filter(RMSE == min(RMSE)) |>
  ungroup()
```

```{r}
#| label: error-comp-pbmc-umap

error_umap_plot_pbmc <-  plot_rmse(error_pbmc) +
  scale_x_continuous(breaks = sort(unique(error_pbmc$a1))[c(1, 5, 9, 12, 15, 17, 19, 20)]) +
  scale_color_manual(values=c('#377eb8', '#e41a1c'))
```

```{r}
#| label: fig-pbmc-mse-umap
#| fig-pos: H
#| out-width: 100%
#| fig-cap: "Assessing which of the two layouts with UMAP and tSNE with different hyper-parameter setting (n_neighbors: $30$, min_dist: $0.3$ (red); n_neighbors: $30$ (blue)) on the PBMC data is the better representation using RMSE for varying binwidth ($a_1$). Colour used for the lines and points in the top plot and in the scatterplots represents UMAP and tSNE layouts (a, b). Of the two, layout b is optimal across all binwidths making it the best choice."

# Define the layout design
layout_design <- "
AA
BC
"

# Combine the plots using the layout
(error_umap_plot_pbmc + nldr1c + nldr2c) +
  plot_layout(design = layout_design)
```

The RMSE vs binwidth ($a_1$) plot (@fig-pbmc-mse-umap) illustrates that our approach would suggest that scDEED is correct here, that layout b is more accurately reflecting the cluster structure in the PBMC data.

<!--pbmc3k/15_gen_model_with_UMAP_scDEED.R-->
```{r}
#| label: hexbin-pbmc

umap_pbmc_scaled_with_cluster <- read_rds("data/pbmc3k/umap_pbmc_scaled_with_cluster_scDEED.rds")

tr_from_to_df_pbmc <- read_rds("data/pbmc3k/tr_from_to_df_pbmc_scDEED.rds")

trimesh_removed_pbmc <- ggplot() + 
  geom_point(
    data = umap_pbmc_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3#,
    #size = 0.1
  )  +
  geom_segment(data = tr_from_to_df_pbmc, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada")) +
  interior_annotation("a1", cex = 2) +
  theme(
    aspect.ratio = 1
  )
```


```{r}
#| label: pbmc-umap-model-proj

proj_obj1 <- read_rds("data/pbmc3k/proj_obj1_umap_scDEED.rds")

pbmc_proj_umap_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.04, 0.045), 
  axis_text_size = 4,
  is_category = TRUE) + 
  interior_annotation(label = "a2", cex = 2) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada"))

proj_obj2 <- read_rds("data/pbmc3k/proj_obj2_umap_scDEED.rds")

pbmc_proj_umap_model2 <- plot_proj(
    proj_obj = proj_obj2, 
    point_param = c(1.5, 0.2), # size, alpha, color
    plot_limits = c(-0.03, 0.03), 
    axis_text_size = 4,
    is_category = TRUE) +
  interior_annotation(label = "a3", cex = 2) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada"))

```

<!--pbmc3k/16_gen_model_with_tSNE_scDEED.R-->
```{r}
#| label: hexbin-pbmc2

tsne_pbmc_scaled_with_cluster <- read_rds("data/pbmc3k/tsne_pbmc_scaled_with_cluster_scDEED.rds")

tr_from_to_df_pbmc <- read_rds("data/pbmc3k/tr_from_to_df_pbmc_tsne_scDEED.rds")

trimesh_removed_pbmc_best <- ggplot() + 
  geom_point(
    data = tsne_pbmc_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3#,
    #size = 0.1
  )  +
  geom_segment(data = tr_from_to_df_pbmc, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada")) +
  interior_annotation("b1", cex = 2) +
  theme(
    aspect.ratio = 1
  )
```

```{r}
#| label: pbmc-tsne-model-proj-best

proj_obj1 <- read_rds("data/pbmc3k/proj_obj1_tsne_scDEED.rds")

pbmc_proj_tsne_model1_best <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.04, 0.045), 
  axis_text_size = 4,
  is_category = TRUE) + 
  interior_annotation(label = "b2", cex = 2) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada"))

proj_obj2 <- read_rds("data/pbmc3k/proj_obj2_tsne_scDEED.rds")

pbmc_proj_tsne_model2_best <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.03, 0.03), 
  axis_text_size = 4,
  is_category = TRUE) + 
  interior_annotation(label = "b3", cex = 2) +
  scale_color_manual(values = c("#8dd3c7", "#fdb462", "#bebada"))

```

```{r}
#| echo: false
#| fig-cap: "Compare the published \\gD{} layout (@fig-pbmc-mse-umap a) and the \\gD{} layout selected (@fig-pbmc-mse-umap b) by RMSE plot (@fig-pbmc-mse-umap) from tSNE and UMAP with default hyper-parameters. The PBMC data ($n =  5858$) has three clusters in $9\\text{-}D$, where three clusters are close. Two \\gD{} projection from a tour on $9\\text{-}D$ of the model fit with @fig-pbmc-mse-umap a ($a_1 = 0.04$, $b = 900/179 (30, 30)$) shows three-well separated clusters with big separations. On the other hand, the model fit with @fig-pbmc-mse-umap b ($a_1 = 0.04$, $b = 1110/317 (30, 37)$) shows three-well separated clusters with small separations. Therefore, @fig-pbmc-mse-umap b is more reasonable than @fig-pbmc-mse-umap a. Videos of the langevitour animations are available at <https://youtu.be/0cKX_HG_n0k> and <https://youtu.be/KhJvsRtaX04> respectively."
#| label: fig-model-pbmc-author-proj
#| fig-pos: H
#| fig-width: 10
#| fig-height: 15
#| out-width: 90%

free(trimesh_removed_pbmc) + free(trimesh_removed_pbmc_best) +
  pbmc_proj_umap_model1 + pbmc_proj_tsne_model1_best +
  pbmc_proj_umap_model2 + pbmc_proj_tsne_model2_best +
  plot_layout(nrow=2, byrow=FALSE) &
  theme(legend.position='none')
```

