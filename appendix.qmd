---
title: "Appendix: Visualising How Non-linear Dimension Reduction Warps Your Data"
author:
  - name: Jayani P.G. Lakshika
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Austria
        postal-code: 3800
    orcid: 0000-0002-6265-6481
    email: jayani.piyadigamage@monash.edu
    url: https://jayanilakshika.netlify.app/
  - name: Dianne Cook
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Austria
        postal-code: 3800
    orcid: 0000-0002-3813-7155
    email: dicook@monash.edu 
    url: http://www.dicook.org/
  - name: Paul Harrison
    affiliations:
      - name: Monash University
        department: MGBP, BDInstitute
        address: Clayton
        city: VIC 
        country: Austria
        postal-code: 3800
    orcid: 0000-0002-3980-268X
    email: 	paul.harrison@monash.edu
    url: 
  - name: Michael Lydeamore
    affiliations:
      - name: Monash University
        department: Econometrics & Business Statistics
        address: Clayton
        city: VIC 
        country: Austria
        postal-code: 3800
    orcid: 0000-0001-6515-827X
    email: michael.lydeamore@monash.edu
    url: 
  - name: Thiyanga S. Talagala
    affiliations:
      - name: University of Sri Jayewardenepura
        department: Statistics
        address: Gangodawila
        city: Nugegoda 
        country: Sri Lanka
        postal-code: 10100
    orcid: 0000-0002-0656-9789
    email: ttalagala@sjp.ac.lk 
    url: https://thiyanga.netlify.app/
tbl-cap-location: bottom
---

```{r}
#| warning: false
#| echo: false
library(dplyr)
# remotes::install_github("jlmelville/snedata")
library(snedata)
library(ggflowchart)
library(purrr) ## map function
library(gridExtra) ## for grid.arrange
library(rsample)
library(DT)
library(ggbeeswarm)
library(ggplot2)
library(readr)

library(Rtsne)
library(umap)
library(phateR)
library(reticulate)
library(patchwork)

library(grid)


# install.packages("Seurat")
# remotes::install_github("satijalab/seurat-data")
#library(SeuratData) ## For the application

# use_python("~/miniforge3/envs/pcamp_env/bin/python")
# use_condaenv("pcamp_env")
# 
# reticulate::source_python(paste0(here::here(), "/examples_for_the_paper/function_scripts/Fit_PacMAP_code.py"))
# reticulate::source_python(paste0(here::here(), "/examples_for_the_paper/function_scripts/Fit_TriMAP_code.py"))

set.seed(20230531)

source("quollr_code.R", local = TRUE)
source("nldr_code.R", local = TRUE)
```


```{r}
#| warning: false
#| echo: false

data <- read_rds("data/s_curve/s_curve.rds")
```

```{r}
#| warning: false
#| echo: false

training_data <- read_rds("data/s_curve/s_curve_training.rds")
test_data <- read_rds("data/s_curve/s_curve_test.rds")
```

```{r}
#| echo: false

UMAP_data <- read_rds("data/s_curve/s_curve_umap.rds")

num_bins_x <- calculate_effective_x_bins(.data = UMAP_data, x = UMAP1,
                           cell_area = 1)

shape_value <- calculate_effective_shape_value(.data = UMAP_data, 
                                             x = UMAP1, y = UMAP2)

## To extract bin centroids
hexbin_data_object <-extract_hexbin_centroids(nldr_df = UMAP_data, num_bins = num_bins_x, shape_val = shape_value)
    
df_bin_centroids <- hexbin_data_object$hexdf_data

##########

## Data set with all possible centroids in the hexagonal grid

full_centroid_df <- generate_full_grid_centroids(df_bin_centroids)

## To map hexID to hexbin centroids in the full grid

vec1 <- stats::setNames(rep("", 2), c("x", "y"))  ## Define column names

full_grid_with_hexbin_id <- dplyr::bind_rows(vec1)[0, ]
full_grid_with_hexbin_id <- full_grid_with_hexbin_id |>
  dplyr::mutate_if(is.character, as.numeric)

for(i in 1:length(sort(unique(full_centroid_df$y)))){
  
  ## Filter the data set with specific y value
  specific_y_val_df <- full_centroid_df |>
    dplyr::filter(y == sort(unique(full_centroid_df$y))[i])
  
  ordered_x_df <- specific_y_val_df |>
    dplyr::arrange(x) 
  
  full_grid_with_hexbin_id <- dplyr::bind_rows(full_grid_with_hexbin_id, ordered_x_df)
  
}


full_grid_with_hexbin_id <- full_grid_with_hexbin_id |>
  dplyr::mutate(hexID = row_number())

full_grid_with_hexbin_id <- full_grid_with_hexbin_id |>
  dplyr::rename("c_x" = "x",
         "c_y" = "y") 

full_grid_with_hexbin_id <- dplyr::full_join(full_grid_with_hexbin_id, df_bin_centroids, by = c("hexID" = "hexID")) |>
  dplyr::select(-c(x, y)) #|> 
  #dplyr::mutate(counts = tidyr::replace_na(counts, 0))

full_grid_with_hexbin_id <- full_grid_with_hexbin_id |>
    dplyr::mutate(std_counts = counts/max(counts, na.rm = TRUE))

## Generate all coordinates of hexagons
hex_grid <- full_hex_grid(full_centroid_df)

full_grid_with_polygon_id_df <- map_polygon_id(full_grid_with_hexbin_id, hex_grid)

full_grid_with_hexbin_id_rep <- full_grid_with_polygon_id_df |>
  dplyr::slice(rep(1:n(), each = 6)) |>
  dplyr::arrange(polygon_id)

hex_full_count_df <- dplyr::bind_cols(hex_grid, full_grid_with_hexbin_id_rep)

##########

min_std_cell_threshold <- 0.05

df_bin_centroids_all <- hexbin_data_object$hexdf_data ## All the centroids without removing low-density hexagons


df_bin_centroids <- df_bin_centroids |>
  dplyr::mutate(stand_cell_count = counts/max(counts)) |>
  dplyr::filter(stand_cell_count > min_std_cell_threshold)
        
UMAP_data_with_hb_id <- UMAP_data |> 
  dplyr::mutate(hb_id = hexbin_data_object$hb_data@cID)
        
## To generate a data set with high-D and 2D training data
df_all <- dplyr::bind_cols(training_data |> dplyr::select(-ID), UMAP_data_with_hb_id)
        
## Averaged on high-D
df_bin <- avg_highD_data(.data = df_all)

## Triangulate bin centroids
tr1_object <- triangulate_bin_centroids(df_bin_centroids, x, y)
tr_from_to_df <- generate_edge_info(triangular_object = tr1_object)

## Compute 2D distances
distance <- cal_2D_dist(.data = tr_from_to_df)

## To find the benchmark value
benchmark <- find_benchmark_value(.data = distance, distance_col = distance)


trimesh <- ggplot(df_bin_centroids, aes(x = x, y = y)) + 
    geom_segment(data = tr_from_to_df, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
    geom_point(size = 2, colour = "#33a02c") +
    coord_equal()
  
  # ggplot(df_bin_centroids, aes(x = x, y = y)) + 
  # geom_point(size = 1, colour = "#33a02c") + 
  # geom_trimesh() + 
  # coord_equal() 

trimesh <- trimesh +
  #ggtitle("(a)") + 
  xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  theme_light() +
    theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
    ) 
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7))

trimesh_gr <- colour_long_edges(.data = distance, benchmark_value = benchmark, 
                                triangular_object = tr1_object, distance_col = distance) 

trimesh_gr <- trimesh_gr + 
    geom_point(size = 2, colour = "#33a02c") + 
  #ggtitle("(b)") + 
  xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  theme_light() +
    #coord_equal() +
    theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
    ) 

trimesh_removed <- remove_long_edges(.data = distance, benchmark_value = benchmark, 
                                triangular_object = tr1_object, distance_col = distance)

trimesh_removed <- trimesh_removed + 
       geom_point(size = 2, colour = "#33a02c") + 
  #ggtitle("(b)") + 
  xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  theme_light() +
    #coord_equal() +
    theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
    ) 



tour1 <- show_langevitour(df_all, df_bin, df_bin_centroids, benchmark_value = benchmark, distance = distance, distance_col = distance)
```

```{r}
#| echo: false


## To plot the distribution of distance
plot_dist <- function(distance_df){
  distance_df$group <- "1"
  dist_plot <- ggplot(distance_df, aes(x = group, y = distance)) +
    geom_quasirandom()+
    ylim(0, max(unlist(distance_df$distance))+ 0.5) + coord_flip()
  return(dist_plot)
}
```

```{r}
#| echo: false

distance_plot <- plot_dist(distance) +
  #ggtitle("(b)" ) + 
  ylab(expression(d^{(2)})) +
  theme(axis.text = element_text(size = 5),
        axis.title = element_text(size = 12))
```

## Notations

| Notation                                                                                                              | Description                                                            |
|-----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------|
| $n$                                                                                                                   | number of observations                                                 |
| $p$                                                                                                                   | number of dimensions in high-D data                                    |
| $X_{n \times p} = \begin{bmatrix} \textbf{x} _{1} & \textbf{x}_ {2} & \cdots & \textbf{x}_{n} \\  \end{bmatrix}^\top$ | high-D data matrix                                                     |
| $d$                                                                                                                   | number of dimensions in embedding data, usually two                    |
| $Y_{n \times d} = \begin{bmatrix} \textbf{y} _{1} & \textbf{y}_ {2} & \cdots & \textbf{y}_{n} \\  \end{bmatrix}^\top$ | embedding matrix                                                       |
| $P_t$                                                                                                                 | point along the geodesic path at time $t$                              |
| $P_{t+1}$                                                                                                             | point along the geodesic path at the next time instant, which is $t+1$ |
| $b_1$                                                                                                                 | number of bins along the x-axis                                        |
| $b_2$                                                                                                                 | number of bins along the y-axis                                        |
| $b$                                                                                                                   | total number of bins in the hexagonal grid                             |
| $b'$                                                                                                                  | total number of bins without the empty bins                            |
| $h$                                                                                                                   | diameter of a hexagon                                                  |
| $A$                                                                                                                   | area of a hexagon                                                      |
| $r_1$                                                                                                                 | 2D embedding component 1                                               |
| $r_2$                                                                                                                 | 2D embedding component 2                                               |
| $s$                                                                                                                   | shape parameter                                                        |
| $C_k^{(2)} \equiv (C_{ky_1}, C_{ky_2})$                                                                               | hexagonal bin centroid coordinates                                     |
| $C_k^{(p)} \equiv (C_{kx_1}, ..., C_{kx_p})$                                                                          | averaged high-D coordinates                                            |
: Notations used in this paper and their descriptions. {#tbl-notations}


## Default parameter values

### Benchmark value to remove low-density hexagons

Removing all the bins that have a standard number of points less than a certain benchmark value will generate unnecessary holes within the triangular mesh. Therefore, before removing the low-density bins, it's necessary to investigate the number of points in neighboring bins as well. 

$$
\text{standard count} = \frac{\text{count}}{\text{max count}} 
$${#eq-equationp2}

The process begins by identifying the six nearest hex bins of specified low-density hex bins. To identify the nearest hex bins 2D Euclidean distance metric is used. Then, we calculate the mean density, as outlined in the equations:

$$
\text{mean density} = \frac{\text{standard count}}{6} 
$${#eq-equationp3}

The standard count is derived from the number of observations in the hex bins. By examining the distribution of mean densities and designating the first quartile as the benchmark value, hex bins with mean densities below this benchmark are removed. This process ensures the elimination of regions with insufficient data density, focusing on areas with more significant data representation and preserving the overall structure in the low-dimensional space.

### Benchmark value to remove long edges {#sec-rmlgdefault}

Determining a benchmark value for removing long edges isn't a straightforward process with standard guidelines. Having a default value provides a practical starting point for decision-making, helping users choose whether to stick with the default, choose a value below it, or select one above it for long edge removal.

To calculate the default value, the process involves computing the 2D Euclidean distances between the vertices in the triangular mesh. Initially, distances between vertices are sorted. Then, unique distance values are extracted. Following this, the differences between consecutive distance values are computed, and a data frame is constructed with unique distance values and their corresponding differences. The first largest difference is then used as a benchmark to identify and remove the long edges.

![A flow diagram detailing the steps taken to find the benchmark value to remove long edges.](figures/remove_long_edges_workflow.png){#fig-rmlgmeth fig-align="center" width="100%" height="100%"}

```{r}
#| echo: false

dist_p <- plot_dist(distance)  +
  geom_hline(yintercept = benchmark, colour = "blue") + 
  ylab(expression(d^{(2)})) +
  theme(axis.text = element_text(size = 5),
        axis.title = element_text(size = 12)) 
```

```{r}
#| echo: false
#| warning: false
#| fig-cap: "Is the default benchmark value effective in removing the long edges to construct a smooth surface in 2D? (a) Triangular mesh with coloured edges by their type, (b) Distribution of 2D Euclidean distances between triangular mesh vertices."
#| label: fig-defaultrmlg
##| out-width: 100%

trimesh_gr + dist_p +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='bottom', plot.tag = element_text(size = 8))
```

## Paramter tunning

### Total number of bins

The total number of bins represents the overall count of hexagonal bins within the hexagonal grid. This count is determined by multiplying the number of bins along the x-axis ($b_1$) with the number of bins along the y-axis ($b_2$), according to the formula:

$$
 b = b_1 \times b_2
$$ {#eq-equationp1}

Here, $b$ denotes the total number of bins. By adjusting the parameter $b_1$, we have control over the total number of bins ($b$). Hence, fine-tuning $b_1$ enables us to customize and optimize the total bin count based on the desired configuration along the x-axis.

```{r}
#| echo: false
#| message: false
#| warning: false

hexgrid_with_points_hex <- ggplot(data = hex_full_count_df |> dplyr::filter(!is.na(std_counts)), aes(x = c_x, y = c_y, fill = std_counts, hexID = hexID)) + 
    geom_hex(stat = "identity", color = "#969696") +
  scale_fill_viridis_c(direction = -1, na.value = "#ffffff", option = "C") +
  theme_light() +
    #coord_equal() +
    theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
    ) 

```

```{r}
#| echo: false
#| message: false
#| warning: false

hexgrid_with_points_m <- ggplot(data = hex_full_count_df, aes(x = x, y = y)) + 
  geom_polygon(color = "black", aes(group = polygon_id, fill = std_counts)) + 
  scale_fill_viridis_c(direction = -1, na.value = "#ffffff", option = "C") +
  theme_light() +
    #coord_equal() +
    theme(plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
    ) 

hexgrid_with_points <- hexgrid_with_points_m + theme(legend.position = "none")
```


```{r}
#| echo: false
#| message: false
#| warning: false
#| out-width: 100%

hexgrid_with_points_hex + hexgrid_with_points +
  plot_layout(ncol = 3)

```
<!--
```{r}
#| echo: false
#| message: false
#| warning: false
 # Loop over loop.vector
  #i <- 1
  num_bins <- 3
  shape_val <- calculate_effective_shape_value(.data = UMAP_data, x = UMAP1, y = UMAP2)

  hexbin_data_object_loop <- extract_hexbin_centroids(UMAP_data, num_bins, shape_val)

  df_bin_centroids_loop <- hexbin_data_object_loop$hexdf_data

  ## Data set with all possible centroids in the hexagonal grid

  full_centroid_df_loop <- generate_full_grid_centroids(df_bin_centroids_loop)

  ## To map hexID to hexbin centroids in the full grid

  vec1 <- stats::setNames(rep("", 2), c("x", "y"))  ## Define column names

  full_grid_with_hexbin_id_loop <- dplyr::bind_rows(vec1)[0, ]
  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::mutate_if(is.character, as.numeric)

  for(i in 1:length(sort(unique(full_centroid_df_loop$y)))){

    ## Filter the data set with specific y value
    specific_y_val_df_loop <- full_centroid_df_loop |>
      dplyr::filter(y == sort(unique(full_centroid_df_loop$y))[i])

    ordered_x_df_loop <- specific_y_val_df_loop |>
      dplyr::arrange(x)

    full_grid_with_hexbin_id_loop <- dplyr::bind_rows(full_grid_with_hexbin_id_loop, ordered_x_df_loop)

  }


  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::mutate(hexID = row_number())

  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::rename("c_x" = "x",
           "c_y" = "y")

  full_grid_with_hexbin_id_loop <- dplyr::full_join(full_grid_with_hexbin_id_loop, df_bin_centroids_loop, by = c("hexID" = "hexID")) |>
    dplyr::select(-c(x, y))

  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
      dplyr::mutate(std_counts = counts/max(counts, na.rm = TRUE))

  ## Generate all coordinates of hexagons
  hex_grid_loop <- full_hex_grid(full_centroid_df_loop)

  full_grid_with_polygon_id_df_loop <- map_polygon_id(full_grid_with_hexbin_id_loop, hex_grid_loop)

  full_grid_with_hexbin_id_rep_loop <- full_grid_with_polygon_id_df_loop |>
  dplyr::slice(rep(1:n(), each = 6)) |>
  dplyr::arrange(polygon_id)

  hex_full_count_df_loop <- dplyr::bind_cols(hex_grid_loop, full_grid_with_hexbin_id_rep_loop)



  p1 <-  ggplot(data = hex_full_count_df_loop, aes(x = x, y = y)) +
  geom_polygon(color = "black", aes(group = polygon_id, fill = std_counts)) +
        geom_point(data = UMAP_data, aes(x = UMAP1, y = UMAP2), alpha = 0.5) +
  scale_fill_viridis_c(direction = -1, na.value = "#ffffff", option = "C") +
    theme_void() +
    theme(legend.position="none", legend.direction="horizontal", plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
          legend.title = element_text(size=8), #change legend title font size
          legend.text = element_text(size=6)) +
    guides(fill = guide_colourbar(title = "Standardized count")) +
    annotate(geom = 'text', label = "a", x = -Inf, y = Inf, hjust = -0.3, vjust = 1, size = 3) 

```


```{r}
#| echo: false
#| message: false
#| warning: false
 # Loop over loop.vector
  #i <- 1
  num_bins <- 8
  shape_val <- calculate_effective_shape_value(.data = UMAP_data, x = UMAP1, y = UMAP2)

  hexbin_data_object_loop <- extract_hexbin_centroids(UMAP_data, num_bins, shape_val)

  df_bin_centroids_loop <- hexbin_data_object_loop$hexdf_data

  ## Data set with all possible centroids in the hexagonal grid

  full_centroid_df_loop <- generate_full_grid_centroids(df_bin_centroids_loop)

  ## To map hexID to hexbin centroids in the full grid

  vec1 <- stats::setNames(rep("", 2), c("x", "y"))  ## Define column names

  full_grid_with_hexbin_id_loop <- dplyr::bind_rows(vec1)[0, ]
  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::mutate_if(is.character, as.numeric)

  for(i in 1:length(sort(unique(full_centroid_df_loop$y)))){

    ## Filter the data set with specific y value
    specific_y_val_df_loop <- full_centroid_df_loop |>
      dplyr::filter(y == sort(unique(full_centroid_df_loop$y))[i])

    ordered_x_df_loop <- specific_y_val_df_loop |>
      dplyr::arrange(x)

    full_grid_with_hexbin_id_loop <- dplyr::bind_rows(full_grid_with_hexbin_id_loop, ordered_x_df_loop)

  }


  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::mutate(hexID = row_number())

  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::rename("c_x" = "x",
           "c_y" = "y")

  full_grid_with_hexbin_id_loop <- dplyr::full_join(full_grid_with_hexbin_id_loop, df_bin_centroids_loop, by = c("hexID" = "hexID")) |>
    dplyr::select(-c(x, y))

  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
      dplyr::mutate(std_counts = counts/max(counts, na.rm = TRUE))

  ## Generate all coordinates of hexagons
  hex_grid_loop <- full_hex_grid(full_centroid_df_loop)

  full_grid_with_polygon_id_df_loop <- map_polygon_id(full_grid_with_hexbin_id_loop, hex_grid_loop)

  full_grid_with_hexbin_id_rep_loop <- full_grid_with_polygon_id_df_loop |>
  dplyr::slice(rep(1:n(), each = 6)) |>
  dplyr::arrange(polygon_id)

  hex_full_count_df_loop <- dplyr::bind_cols(hex_grid_loop, full_grid_with_hexbin_id_rep_loop)



  p2 <-  ggplot(data = hex_full_count_df_loop, aes(x = x, y = y)) +
  geom_polygon(color = "black", aes(group = polygon_id, fill = std_counts)) +
    geom_point(data = UMAP_data, aes(x = UMAP1, y = UMAP2), alpha = 0.5) +
  scale_fill_viridis_c(direction = -1, na.value = "#ffffff", option = "C") +
        theme_void() +
    theme(legend.position="none", legend.direction="horizontal", plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
          legend.title = element_text(size=8), #change legend title font size
          legend.text = element_text(size=6)) +
    guides(fill = guide_colourbar(title = "Standardized count")) +
    annotate(geom = 'text', label = "b", x = -Inf, y = Inf, hjust = -0.3, vjust = 1, size = 3) 

```

```{r}
#| echo: false
#| message: false
#| warning: false
 # Loop over loop.vector
  #i <- 1
  num_bins <- 15
  shape_val <- calculate_effective_shape_value(.data = UMAP_data, x = UMAP1, y = UMAP2)

  hexbin_data_object_loop <- extract_hexbin_centroids(UMAP_data, num_bins, shape_val)

  df_bin_centroids_loop <- hexbin_data_object_loop$hexdf_data

  ## Data set with all possible centroids in the hexagonal grid

  full_centroid_df_loop <- generate_full_grid_centroids(df_bin_centroids_loop)

  ## To map hexID to hexbin centroids in the full grid

  vec1 <- stats::setNames(rep("", 2), c("x", "y"))  ## Define column names

  full_grid_with_hexbin_id_loop <- dplyr::bind_rows(vec1)[0, ]
  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::mutate_if(is.character, as.numeric)

  for(i in 1:length(sort(unique(full_centroid_df_loop$y)))){

    ## Filter the data set with specific y value
    specific_y_val_df_loop <- full_centroid_df_loop |>
      dplyr::filter(y == sort(unique(full_centroid_df_loop$y))[i])

    ordered_x_df_loop <- specific_y_val_df_loop |>
      dplyr::arrange(x)

    full_grid_with_hexbin_id_loop <- dplyr::bind_rows(full_grid_with_hexbin_id_loop, ordered_x_df_loop)

  }


  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::mutate(hexID = row_number())

  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
    dplyr::rename("c_x" = "x",
           "c_y" = "y")

  full_grid_with_hexbin_id_loop <- dplyr::full_join(full_grid_with_hexbin_id_loop, df_bin_centroids_loop, by = c("hexID" = "hexID")) |>
    dplyr::select(-c(x, y))

  full_grid_with_hexbin_id_loop <- full_grid_with_hexbin_id_loop |>
      dplyr::mutate(std_counts = counts/max(counts, na.rm = TRUE))

  ## Generate all coordinates of hexagons
  hex_grid_loop <- full_hex_grid(full_centroid_df_loop)

  full_grid_with_polygon_id_df_loop <- map_polygon_id(full_grid_with_hexbin_id_loop, hex_grid_loop)

  full_grid_with_hexbin_id_rep_loop <- full_grid_with_polygon_id_df_loop |>
  dplyr::slice(rep(1:n(), each = 6)) |>
  dplyr::arrange(polygon_id)

  hex_full_count_df_loop <- dplyr::bind_cols(hex_grid_loop, full_grid_with_hexbin_id_rep_loop)



  p3 <-  ggplot(data = hex_full_count_df_loop, aes(x = x, y = y)) +
  geom_polygon(color = "black", aes(group = polygon_id, fill = std_counts)) +
        geom_point(data = UMAP_data, aes(x = UMAP1, y = UMAP2), alpha = 0.5) +
  scale_fill_viridis_c(direction = -1, na.value = "#ffffff", option = "C") +
        theme_void() +
    theme(legend.position="none", legend.direction="horizontal", plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
          legend.title = element_text(size=8), #change legend title font size
          legend.text = element_text(size=6)) +
    guides(fill = guide_colourbar(title = "Standardized count")) +
    annotate(geom = 'text', label = "c", x = -Inf, y = Inf, hjust = -0.3, vjust = 1, size = 3) 

```

```{r}
#| echo: false
#| label: fig-binsize
#| fig-pos: H
#| fig-cap: "Hexbin plots from different number of bins for the same **s_curve_noise_umap** data: (a) b = (4, 8), s = 2.031, (b) b = (9, 20), s = 2.031, and (c) b = (16, 36), s = 2.031. The hexbins are colored based on the density of points, with yellow indicating higher point density and darker colors representing lower point density within each bin. Does  a value of number of bins exist to effectively represent the low-dimensional data?"

p1 + p2 + p3
```
-->

### Benchmark value to remove low-density hexagons

Addressing low-density hexagons is a systematic process to handle sparsely represented data in certain regions. For each hex bin, we identify the six nearest hex bins using an equal 2D distance metric. Then, we calculate the mean density, as outlined in the equations:

$$
\text{standard count} = \frac{\text{count}}{\text{max count}} 
$${#eq-equationp2}

$$
\text{mean density} = \frac{\text{standard count}}{6} 
$${#eq-equationp3}

The standard count is derived from the number of observations in the hex bins. By examining the distribution of mean densities and designating the first quartile as the benchmark value, hex bins with mean densities below this benchmark are removed. This process ensures the elimination of regions with insufficient data density, focusing on areas with more significant data representation and preserving the overall structure in the low-dimensional space.

<!--
In the step of addressing low-density hexagons, which can arise from sparsely represented data in certain regions, we employ a systematic strategy. The goal is to ensure a more comprehensive coverage of the data by removing hexagons with low data density. To achieve this, we initiate the process by identifying, for each hex bin, the six nearest hex bins based on an equal 2D distance metric. Following this, we calculate the mean density (see @eq-equationp3), as outlined in the equation:

$$
 \text{standard count} = \frac{\text{count}}{\text{max count}}
$$ {#eq-equationp2}

$$
 \text{mean density} = \frac{\text{standard count}}{6}
$$ {#eq-equationp3}


The standard count is derived from the number of observations in the hex bins (see @eq-equationp2). Next, we examine the distribution of mean densities across all hex bins and designate the first quartile as the benchmark value for removing low-density hexagons. Finally, hex bins with mean densities below this benchmark value are removed from consideration. This meticulous procedure ensures the elimination of regions with inadequate data density, allowing the focus to shift to areas with more significant data representation. The result is the preservation of the overall structure of the data in the low-dimensional space, as illustrated in @fig-bintorm (c).
-->


```{r}
#| echo: false

df_bin_centroids <- df_bin_centroids |>
  dplyr::mutate(ID = row_number())

# To store mean densities of hexagons
mean_density_vec <- c()

for (i in 1:length(df_bin_centroids$hexID)) {

  df_bin_centroids_coordinates_spec_bin <- df_bin_centroids |>
    filter(hexID == df_bin_centroids$hexID[i])

  available_near_check <- df_bin_centroids |>
    dplyr::filter((hexID == (df_bin_centroids$hexID[i] + 1)) | (hexID == (df_bin_centroids$hexID[i] - 1))) |>
    head(1)

  if (NROW(available_near_check) == 0) {

    df_bin_centroids_coordinates_spec_bin_near1 <- df_bin_centroids |>
      filter((hexID == (df_bin_centroids$hexID[i] + (num_bins_x + 1))) | (hexID == (df_bin_centroids$hexID[i] + num_bins_x)) | (hexID == (df_bin_centroids$hexID[i] - (num_bins_x + 1))) | (hexID == (df_bin_centroids$hexID[i] - num_bins_x))) |>
      head(1)

  } else {

    df_bin_centroids_coordinates_spec_bin_near1 <- df_bin_centroids |>
      filter((hexID == (df_bin_centroids$hexID[i] + 1)) | (hexID == (df_bin_centroids$hexID[i] - 1))) |>
      head(1)

  }

  near_df_1 <- dplyr::bind_rows(df_bin_centroids_coordinates_spec_bin, df_bin_centroids_coordinates_spec_bin_near1)

  start <- unlist(near_df_1[1, c("x","y")])
  end <- unlist(near_df_1[2, c("x","y")])
  nearest_dist <- sqrt(sum((start - end)^2)) # Distance to nearest centroid

  df_bin_centroids$distance <- lapply(seq(nrow(df_bin_centroids)), function(x) {
    start <- unlist(df_bin_centroids[(df_bin_centroids_coordinates_spec_bin |> pull(ID)), c("x","y")])
    end <- unlist(df_bin_centroids[x, c("x","y")])
    sqrt(sum((start - end)^2))})

  df_bin_centroids <- df_bin_centroids %>%
    dplyr::select(names(df_bin_centroids), "distance")

  df_bin_centroids$distance <- round(unlist(df_bin_centroids$distance), 7)

  neighbor_df <- df_bin_centroids |>
    filter(distance == round(nearest_dist, 7))

  mean_density <- neighbor_df |>
    pull(std_counts) |>
    sum()/6 ## The reason to take the mean is to check the density in a considerable amount

  mean_density_vec <- append(mean_density_vec, mean_density)

}

df_bin_centroids <- df_bin_centroids |>
  dplyr::mutate(mean_density = mean_density_vec)

cell_count_plot <- ggplot(df_bin_centroids, aes(x = reorder(as.factor(hexID), -mean_density), y = mean_density)) +
  geom_quasirandom() + xlab("hexagonal id") + ylab("Standardized cell count") +
  geom_hline(yintercept = 0.255, colour = "#de2d26") +
  theme(axis.text = element_text(size = 5),
        axis.title = element_text(size = 7),
        axis.text.x = element_text(angle = 90))

cell_count_plot
```

```{r}
#| echo: false

hexgrid_with_points <- hexgrid_with_points +
  coord_equal()

hex_full_count_df <- full_join(hex_full_count_df, df_bin_centroids |> dplyr::select(hexID, mean_density))


hex_full_count_df <- hex_full_count_df |>
  dplyr::mutate(type = if_else(mean_density < 0.255, "low", "high"))

hex_full_count_df_filtered <- hex_full_count_df |>
  dplyr::filter(type == "low")

hex_grid_centers_rm_l_n <- ggplot(data = hex_full_count_df, aes(x = x, y = y)) + 
  geom_polygon(color = "black", aes(group = polygon_id, fill = std_counts))   +
  # geom_polygon(data = hex_full_count_df_filtered, color = "black", aes(group = polygon_id), fill = "red") +
  scale_fill_viridis_c(direction = -1, na.value = "#ffffff", option = "C") +
  theme_light() +
    #coord_equal() +
    theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
          axis.title.x = element_blank(), axis.title.y = element_blank(),
          axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
    ) 

hex_grid_centers_rm_l_n <- hex_grid_centers_rm_l_n +
  geom_text(data = hex_full_count_df_filtered, color = "black", aes(x = c_x, y = c_y, group = polygon_id, label = "X", size = 0.5)) +
  coord_equal() 

hexgrid_with_points + hex_grid_centers_rm_l_n +
  plot_layout(ncol = 2)

```

### Benchmark value to remove long edges 

<!--The removal of long edges is a critical step to create a smoother representation  by iteratively eliminating hexagons with excessive distances between centroids. This process eliminates outliers and noise while preserving essential local relationships within the data. To achieve this, distances between vertices are sorted, and unique distance values are extracted. By setting a threshold based on the largest difference between consecutive distance values, long edges are identified and removed. This refinement step contributes to enhancing the quality of the triangular mesh, ensuring a more accurate representation of the data structure.
-->

Creating a smooth surfaces in 2D involves experimenting with various benchmark values. The challenge lies in determining the most effective benchmark value. This is precisely why the default value was introduced, as outlined in @sec-rmlgdefault, serving as a fundamental reference. To assess its effectiveness, a visual inspection of the triangular mesh is conducted to verify whether it successfully eliminates long edges. If it does, proceeding with that value is a effective choice; if not, it signals the initiation of the tuning process. @fig-diffrmlg shows how the 2D triangular meshes look after removing long edges with different benchmark values. Higher values tend to retain long edges, while lower values may remove not only long edges but also shorter ones.

```{r}
#| warning: false
#| echo: false

## Import data

UMAP_s_curve <- read_rds("data/s_curve/s_curve_umap.rds")

## UMAP

num_bins_umap_s_curve <- calculate_effective_x_bins(.data = UMAP_s_curve, x = UMAP1,
                           cell_area = 1)
shape_val_umap_s_curve <- calculate_effective_shape_value(.data = UMAP_s_curve,
                                                          x = UMAP1, y = UMAP2) ## 1.259938
## To extract bin centroids
hexbin_data_object_umap_s_curve <- extract_hexbin_centroids(nldr_df = UMAP_s_curve, num_bins = num_bins_umap_s_curve, shape_val = shape_val_umap_s_curve, x = UMAP1, y = UMAP2)

df_bin_centroids_umap_s_curve <- hexbin_data_object_umap_s_curve$hexdf_data

UMAP_data_with_hb_id_s_curve <- UMAP_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_umap_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_umap_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), UMAP_data_with_hb_id_s_curve)

## Averaged on high-D
df_bin_umap_s_curve <- avg_highD_data(.data = df_all_umap_s_curve)

## Triangulate bin centroids
tr1_object_umap_s_curve <- triangulate_bin_centroids(df_bin_centroids_umap_s_curve, x, y)
tr_from_to_df_umap_s_curve <- generate_edge_info(triangular_object = tr1_object_umap_s_curve)

# ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_umap_s_curve <- cal_2D_dist(.data = tr_from_to_df_umap_s_curve)

## To find the benchmark value
benchmark_umap_s_curve <- find_benchmark_value(.data = distance_umap_s_curve, distance_col = distance)


# colour_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve,
#                   triangular_object = tr1_object_umap_s_curve, distance_col = distance)



trimesh_umap_s_curve <- ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
  geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
  geom_point(size = 2, colour = "#33a02c") +
  coord_equal()

trimesh_umap_s_curve <- trimesh_umap_s_curve +
  #ggtitle("(a)") +
  xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  theme_light() +
  theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
  ) +
  annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 
# theme(axis.text = element_text(size = 5),
#       axis.title = element_text(size = 7))

trimesh_gr_umap_s_curve <- colour_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve, triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_gr_umap_s_curve <- trimesh_gr_umap_s_curve +
  geom_point(size = 2, colour = "#33a02c") +
  #ggtitle("(b)") +
  xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  theme_light() +
  #coord_equal() +
  theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
  ) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)

trimesh_removed_umap_s_curve <- remove_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve,
                                                  triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_removed_umap_s_curve <- trimesh_removed_umap_s_curve +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 

trimesh_removed_umap_s_curve1 <- remove_long_edges(.data = distance_umap_s_curve, benchmark_value = 0.8794136,
                                                  triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_removed_umap_s_curve1 <- trimesh_removed_umap_s_curve1 +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 

trimesh_removed_umap_s_curve2 <- remove_long_edges(.data = distance_umap_s_curve, benchmark_value = 5.0891822,
                                                  triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_removed_umap_s_curve2 <- trimesh_removed_umap_s_curve2 +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'c', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 

```

```{r}
#| echo: false
#| fig-cap: "What is the effective benchmark value to remove long edges? (a) benchmark value = $0.8794136$, (b) benchmark value = $1.696$ (default), and (c) benchmark value = $5.0891822$."
#| label: fig-diffrmlg
##| out-width: 100%

trimesh_removed_umap_s_curve1 + trimesh_removed_umap_s_curve + trimesh_removed_umap_s_curve2 +
  plot_layout(guides='collect', ncol = 3) &
  theme(legend.position='bottom')
```


## Different options to construct the 2D model and lift the model into high-D space

Mainly, the hexagonal bin centroids are used to construct 2D model and averaged high-D data is used to lift the model into high-D space. As options except bin centroids, bin means can used to construct the 2D model. Also, except averaged high-D data, weighted mean can used to lift the model into high-D space. If we use bin centers instead of bin centroids, the triangles are not regular.

- Why bin means? because the distribution of points within hexagonals are not always represented by the center.


### Case 1: Construct 2D model with hexbin means and lift the model into high-D space with averaged high-D data

```{r}
#| warning: false
#| echo: false

## Import data

UMAP_s_curve <- read_rds("data/s_curve/s_curve_umap.rds")

## UMAP

num_bins_umap_s_curve <- calculate_effective_x_bins(.data = UMAP_s_curve, x = UMAP1,
                                         cell_area = 1)
shape_val_umap_s_curve <- calculate_effective_shape_value(.data = UMAP_s_curve,
                                                          x = UMAP1, y = UMAP2) ## 1.259938
## To extract bin centroids
hexbin_data_object_umap_s_curve <- extract_hexbin_mean(nldr_df = UMAP_s_curve, num_bins = num_bins_umap_s_curve, shape_val = shape_val_umap_s_curve, x = UMAP1, y = UMAP2)

df_bin_centroids_umap_s_curve <- hexbin_data_object_umap_s_curve$hexdf_data

## To generate the grid
hexbin_data_object_n <- extract_hexbin_centroids(nldr_df = UMAP_s_curve, num_bins = num_bins_umap_s_curve, shape_val = shape_val_umap_s_curve, x = UMAP1, y = UMAP2)
df_bin_centroids_n <- hexbin_data_object_n$hexdf_data
## Data set with all possible centroids in the hexagonal grid
full_centroid_df <- generate_full_grid_centroids(df_bin_centroids_n)
## Generate all coordinates of hexagons
hex_grid <- full_hex_grid(full_centroid_df)


UMAP_data_with_hb_id_s_curve <- UMAP_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_umap_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_umap_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), UMAP_data_with_hb_id_s_curve)

## Averaged on high-D
df_bin_umap_s_curve <- avg_highD_data(.data = df_all_umap_s_curve)

## Triangulate bin centroids
tr1_object_umap_s_curve <- triangulate_bin_centroids(df_bin_centroids_umap_s_curve, x, y)
tr_from_to_df_umap_s_curve <- generate_edge_info(triangular_object = tr1_object_umap_s_curve)

# ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_umap_s_curve <- cal_2D_dist(.data = tr_from_to_df_umap_s_curve)

## To find the benchmark value
benchmark_umap_s_curve <- find_benchmark_value(.data = distance_umap_s_curve, distance_col = distance)
benchmark_umap_s_curve <- 2.0384346  


# colour_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve,
#                   triangular_object = tr1_object_umap_s_curve, distance_col = distance)



# trimesh_umap_s_curve <- ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()
# 
# trimesh_umap_s_curve <- trimesh_umap_s_curve +
#   #ggtitle("(a)") +
#   xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
#   theme_light() +
#   theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
#         axis.title.x = element_blank(), axis.title.y = element_blank(),
#         axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#         axis.text.y = element_blank(), axis.ticks.y = element_blank(),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
#   ) +
#   annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 
# theme(axis.text = element_text(size = 5),
#       axis.title = element_text(size = 7))

trimesh_removed_umap_s_curve_bin_mean <- remove_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve, triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_removed_umap_s_curve_bin_mean <- trimesh_removed_umap_s_curve_bin_mean +
  geom_point(size = 2, colour = "#33a02c") +
  #ggtitle("(b)") +
  xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  theme_light() +
  #coord_equal() +
  theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
  ) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 


# ### Define type column
# df <- df_all_umap_s_curve |>
#   dplyr::select(tidyselect::starts_with("x")) |>
#   dplyr::mutate(type = "data") ## original dataset
# 
# df_b <- df_bin_umap_s_curve |>
#   dplyr::filter(hb_id %in% df_bin_centroids_umap_s_curve$hexID) |>
#   dplyr::select(-hb_id) |>
#   dplyr::mutate(type = "model") ## Data with summarized mean
# 
# df_exe <- dplyr::bind_rows(df_b, df)
# 
# distance_df_small_edges <- distance_umap_s_curve %>%
#   dplyr::filter(distance < benchmark_umap_s_curve)
# 
# distance_df_long_edges <- distance_umap_s_curve %>%
#   dplyr::filter(distance >= benchmark_umap_s_curve)
# 
# distance_df_edges <- dplyr::bind_rows(distance_df_small_edges, distance_df_long_edges)
# 
# langevitour::langevitour(df_exe[1:(length(df_exe)-1)], lineFrom = distance_df_edges$from , lineTo = distance_df_edges$to, group = df_exe$type, pointSize = 3, levelColors = c("#6a3d9a", "#33a02c"), lineColors = append(rep("black", length(distance_df_small_edges$from)), rep("red", length(distance_df_long_edges$from))))
# 
# show_langevitour(df_all_umap_s_curve, df_bin_umap_s_curve, df_bin_centroids_umap_s_curve, benchmark_value = benchmark_umap_s_curve, distance = distance_umap_s_curve, distance_col = distance)

ggplot(data = hex_grid, aes(x = x, y = y)) + geom_polygon(fill = "white", color = "black", aes(group = id)) +
  geom_point(data = df_bin_centroids_n, aes(x = x, y = y), color = "#33a02c") +
  geom_point(data = df_bin_centroids_umap_s_curve, aes(x = x, y = y), color = "black")

```

```{r}
#| warning: false
#| echo: false

## UMAP
## Prediction

shape_value_curve <- calculate_effective_shape_value(.data = UMAP_s_curve,
                                                   x = UMAP1, y = UMAP2)

num_bins_vec <- 1:13 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 5), c("number_of_bins", "number_of_observations", "total_error", "total_mse", "num_bins_x"))  ## Define column names

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  pred_df_training_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_s_curve, nldr_df_test = UMAP_s_curve, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_training <- pred_df_training_object$pred_data
  centroid_df_training <- pred_df_training_object$df_bin_centroids
  avg_df_training <- pred_df_training_object$df_bin
  
  eval_df_training <- generate_eval_df(data = data, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, num_bins = num_bins_vec[i], col_start = "x")
  
  eval_df_training <- eval_df_training |>
    mutate(num_bins_x = num_bins_vec[i])
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  
  
}


## Add new column with data types

eval_data_training <- eval_data_training |>
  mutate(data_type = "training")

MSE_df_2 <- eval_data_training |>
  dplyr::mutate(method = "UMAP")
```

```{r}
#| warning: false
#| echo: false

#MSE_df <- dplyr::bind_rows(MSE_df_1, MSE_df_2, MSE_df_3, MSE_df_4, MSE_df_5)
MSE_df <- MSE_df_2

MSE_df$method <- factor(MSE_df$method, levels = c("UMAP"))

## To draw with AIC
aic_plot <- ggplot(MSE_df |> dplyr::filter(data_type == "training") |> dplyr::filter(method == "UMAP"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#377eb8", "#e41a1c", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("Total number of bins")
## Effective number of bins along x-axis

mse_plot <- ggplot(MSE_df |> dplyr::filter(method == "UMAP"), aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#377eb8", "#e41a1c", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("Total number of bins")

```

```{r}
#| echo: false
#| fig-cap: "Goodness of fit statistics from different NLDR techniques applied to training S-curve dataset. What is the most effective NLDR technique to represent the original data in a 2D space? What is the effective number of bins in each NLDR technique to create a 2D model?"
#| label: fig-diagnosticpltScurve
##| out-width: 100%

trimesh_removed_umap_s_curve_bin_mean + aic_plot + mse_plot +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='none', plot.tag = element_text(size = 8))
```


### Case 2: Construct 2D model with hexbin centroid and lift the model into high-D space with weighted mean of high-D data

```{r}
#| warning: false
#| echo: false

## Import data

UMAP_s_curve <- read_rds("data/s_curve/s_curve_umap.rds")

## UMAP

num_bins_umap_s_curve <- calculate_effective_x_bins(.data = UMAP_s_curve, x = UMAP1,
                                         cell_area = 1)
shape_val_umap_s_curve <- calculate_effective_shape_value(.data = UMAP_s_curve,
                                                          x = UMAP1, y = UMAP2) ## 1.259938
## To extract bin centroids
hexbin_data_object_umap_s_curve <- extract_hexbin_centroids(nldr_df = UMAP_s_curve, num_bins = num_bins_umap_s_curve, shape_val = shape_val_umap_s_curve, x = UMAP1, y = UMAP2)

df_bin_centroids_umap_s_curve <- hexbin_data_object_umap_s_curve$hexdf_data

## Data set with all possible centroids in the hexagonal grid
full_centroid_df <- generate_full_grid_centroids(df_bin_centroids_umap_s_curve)
## Generate all coordinates of hexagons
hex_grid <- full_hex_grid(full_centroid_df)


UMAP_data_with_hb_id_s_curve <- UMAP_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_umap_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_umap_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), UMAP_data_with_hb_id_s_curve)

## Weighted averaged on high-D
hb_object <- hexbin_data_object_umap_s_curve$hb_data
df_bin_umap_s_curve <- weighted_highD_data(training_data, nldr_df_with_id = UMAP_data_with_hb_id_s_curve, hb_object, column_start_text = "x")


## Triangulate bin centroids
tr1_object_umap_s_curve <- triangulate_bin_centroids(df_bin_centroids_umap_s_curve, x, y)
tr_from_to_df_umap_s_curve <- generate_edge_info(triangular_object = tr1_object_umap_s_curve)

# ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_umap_s_curve <- cal_2D_dist(.data = tr_from_to_df_umap_s_curve)

## To find the benchmark value
benchmark_umap_s_curve <- find_benchmark_value(.data = distance_umap_s_curve, distance_col = distance)
#benchmark_umap_s_curve <- 2.0384346  


# colour_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve,
#                   triangular_object = tr1_object_umap_s_curve, distance_col = distance)



# trimesh_umap_s_curve <- ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()
# 
# trimesh_umap_s_curve <- trimesh_umap_s_curve +
#   #ggtitle("(a)") +
#   xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
#   theme_light() +
#   theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
#         axis.title.x = element_blank(), axis.title.y = element_blank(),
#         axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#         axis.text.y = element_blank(), axis.ticks.y = element_blank(),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
#   ) +
#   annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 
# theme(axis.text = element_text(size = 5),
#       axis.title = element_text(size = 7))

trimesh_removed_umap_s_curve_bin_centroid <- remove_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve, triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_removed_umap_s_curve_bin_centroid <- trimesh_removed_umap_s_curve_bin_centroid +
  geom_point(size = 2, colour = "#33a02c") +
  #ggtitle("(b)") +
  xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  theme_light() +
  #coord_equal() +
  theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
  ) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 


# ### Define type column
# df <- df_all_umap_s_curve |>
#   dplyr::select(tidyselect::starts_with("x")) |>
#   dplyr::mutate(type = "data") ## original dataset
# 
# df_b <- df_bin_umap_s_curve |>
#   dplyr::filter(hb_id %in% df_bin_centroids_umap_s_curve$hexID) |>
#   dplyr::select(-hb_id) |>
#   dplyr::mutate(type = "model") ## Data with summarized mean
# 
# df_exe <- dplyr::bind_rows(df_b, df)
# 
# distance_df_small_edges <- distance_umap_s_curve %>%
#   dplyr::filter(distance < benchmark_umap_s_curve)
# 
# distance_df_long_edges <- distance_umap_s_curve %>%
#   dplyr::filter(distance >= benchmark_umap_s_curve)
# 
# distance_df_edges <- dplyr::bind_rows(distance_df_small_edges, distance_df_long_edges)
# 
# langevitour::langevitour(df_exe[1:(length(df_exe)-1)], lineFrom = distance_df_edges$from , lineTo = distance_df_edges$to, group = df_exe$type, pointSize = 3, levelColors = c("#6a3d9a", "#33a02c"), lineColors = append(rep("black", length(distance_df_small_edges$from)), rep("red", length(distance_df_long_edges$from))))
# 
# show_langevitour(df_all_umap_s_curve, df_bin_umap_s_curve, df_bin_centroids_umap_s_curve, benchmark_value = benchmark_umap_s_curve, distance = distance_umap_s_curve, distance_col = distance)

```

```{r}
#| warning: false
#| echo: false

## UMAP
## Prediction

shape_value_curve <- calculate_effective_shape_value(.data = UMAP_s_curve,
                                                   x = UMAP1, y = UMAP2)

num_bins_vec <- 1:13 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 5), c("number_of_bins", "number_of_observations", "total_error", "total_mse", "num_bins_x"))  ## Define column names

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  pred_df_training_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_s_curve, nldr_df_test = UMAP_s_curve, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_training <- pred_df_training_object$pred_data
  centroid_df_training <- pred_df_training_object$df_bin_centroids
  avg_df_training <- pred_df_training_object$df_bin
  
  eval_df_training <- generate_eval_df(data = data, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, num_bins = num_bins_vec[i], col_start = "x")
  
  eval_df_training <- eval_df_training |>
    mutate(num_bins_x = num_bins_vec[i])
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  
  
}


## Add new column with data types

eval_data_training <- eval_data_training |>
  mutate(data_type = "training")

MSE_df_2 <- eval_data_training |>
  dplyr::mutate(method = "UMAP")
```

```{r}
#| warning: false
#| echo: false

#MSE_df <- dplyr::bind_rows(MSE_df_1, MSE_df_2, MSE_df_3, MSE_df_4, MSE_df_5)
MSE_df <- MSE_df_2

MSE_df$method <- factor(MSE_df$method, levels = c("UMAP"))

## To draw with AIC
aic_plot <- ggplot(MSE_df |> dplyr::filter(data_type == "training") |> dplyr::filter(method == "UMAP"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#377eb8", "#e41a1c", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("Total number of bins")
## Effective number of bins along x-axis

mse_plot <- ggplot(MSE_df |> dplyr::filter(method == "UMAP"), aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#377eb8", "#e41a1c", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("Total number of bins")

```

```{r}
#| echo: false
#| fig-cap: "Goodness of fit statistics from different NLDR techniques applied to training S-curve dataset. What is the most effective NLDR technique to represent the original data in a 2D space? What is the effective number of bins in each NLDR technique to create a 2D model?"
#| label: fig-diagnosticpltScurve2
##| out-width: 100%

trimesh_removed_umap_s_curve_bin_centroid + aic_plot + mse_plot +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='none', plot.tag = element_text(size = 8))
```


### Case 3: Construct 2D model with hexbin means and lift the model into high-D space with weighted mean of high-D data


```{r}
#| warning: false
#| echo: false

## Import data

UMAP_s_curve <- read_rds("data/s_curve/s_curve_umap.rds")

## UMAP

num_bins_umap_s_curve <- calculate_effective_x_bins(.data = UMAP_s_curve, x = UMAP1,
                                         cell_area = 1)
shape_val_umap_s_curve <- calculate_effective_shape_value(.data = UMAP_s_curve,
                                                          x = UMAP1, y = UMAP2) ## 1.259938
## To extract bin centroids
hexbin_data_object_umap_s_curve <- extract_hexbin_mean(nldr_df = UMAP_s_curve, num_bins = num_bins_umap_s_curve, shape_val = shape_val_umap_s_curve, x = UMAP1, y = UMAP2)

df_bin_centroids_umap_s_curve <- hexbin_data_object_umap_s_curve$hexdf_data

## To generate the grid
hexbin_data_object_n <- extract_hexbin_centroids(nldr_df = UMAP_s_curve, num_bins = num_bins_umap_s_curve, shape_val = shape_val_umap_s_curve, x = UMAP1, y = UMAP2)
df_bin_centroids_n <- hexbin_data_object_n$hexdf_data
## Data set with all possible centroids in the hexagonal grid
full_centroid_df <- generate_full_grid_centroids(df_bin_centroids_n)
## Generate all coordinates of hexagons
hex_grid <- full_hex_grid(full_centroid_df)


UMAP_data_with_hb_id_s_curve <- UMAP_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_umap_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_umap_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), UMAP_data_with_hb_id_s_curve)

## Weighted averaged on high-D
hb_object <- hexbin_data_object_umap_s_curve$hb_data
df_bin_umap_s_curve <- weighted_highD_data(training_data, nldr_df_with_id = UMAP_data_with_hb_id_s_curve, hb_object, column_start_text = "x")


## Triangulate bin centroids
tr1_object_umap_s_curve <- triangulate_bin_centroids(df_bin_centroids_umap_s_curve, x, y)
tr_from_to_df_umap_s_curve <- generate_edge_info(triangular_object = tr1_object_umap_s_curve)

# ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_umap_s_curve <- cal_2D_dist(.data = tr_from_to_df_umap_s_curve)

## To find the benchmark value
benchmark_umap_s_curve <- find_benchmark_value(.data = distance_umap_s_curve, distance_col = distance)
benchmark_umap_s_curve <- 2.0384346  


# colour_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve,
#                   triangular_object = tr1_object_umap_s_curve, distance_col = distance)



# trimesh_umap_s_curve <- ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()
# 
# trimesh_umap_s_curve <- trimesh_umap_s_curve +
#   #ggtitle("(a)") +
#   xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
#   theme_light() +
#   theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
#         axis.title.x = element_blank(), axis.title.y = element_blank(),
#         axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#         axis.text.y = element_blank(), axis.ticks.y = element_blank(),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
#   ) +
#   annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 
# theme(axis.text = element_text(size = 5),
#       axis.title = element_text(size = 7))

trimesh_removed_umap_s_curve_bin_mean <- remove_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve, triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_removed_umap_s_curve_bin_mean <- trimesh_removed_umap_s_curve_bin_mean +
  geom_point(size = 2, colour = "#33a02c") +
  #ggtitle("(b)") +
  xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  theme_light() +
  #coord_equal() +
  theme(legend.position = "none", plot.title = element_text(size = 5, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()#change legend key width
  ) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 


# ### Define type column
# df <- df_all_umap_s_curve |>
#   dplyr::select(tidyselect::starts_with("x")) |>
#   dplyr::mutate(type = "data") ## original dataset
# 
# df_b <- df_bin_umap_s_curve |>
#   dplyr::filter(hb_id %in% df_bin_centroids_umap_s_curve$hexID) |>
#   dplyr::select(-hb_id) |>
#   dplyr::mutate(type = "model") ## Data with summarized mean
# 
# df_exe <- dplyr::bind_rows(df_b, df)
# 
# distance_df_small_edges <- distance_umap_s_curve %>%
#   dplyr::filter(distance < benchmark_umap_s_curve)
# 
# distance_df_long_edges <- distance_umap_s_curve %>%
#   dplyr::filter(distance >= benchmark_umap_s_curve)
# 
# distance_df_edges <- dplyr::bind_rows(distance_df_small_edges, distance_df_long_edges)
# 
# langevitour::langevitour(df_exe[1:(length(df_exe)-1)], lineFrom = distance_df_edges$from , lineTo = distance_df_edges$to, group = df_exe$type, pointSize = 3, levelColors = c("#6a3d9a", "#33a02c"), lineColors = append(rep("black", length(distance_df_small_edges$from)), rep("red", length(distance_df_long_edges$from))))
# 
# show_langevitour(df_all_umap_s_curve, df_bin_umap_s_curve, df_bin_centroids_umap_s_curve, benchmark_value = benchmark_umap_s_curve, distance = distance_umap_s_curve, distance_col = distance)

```

```{r}
#| warning: false
#| echo: false

## UMAP
## Prediction

shape_value_curve <- calculate_effective_shape_value(.data = UMAP_s_curve,
                                                   x = UMAP1, y = UMAP2)

num_bins_vec <- 1:13 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 5), c("number_of_bins", "number_of_observations", "total_error", "total_mse", "num_bins_x"))  ## Define column names

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  pred_df_training_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_s_curve, nldr_df_test = UMAP_s_curve, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_training <- pred_df_training_object$pred_data
  centroid_df_training <- pred_df_training_object$df_bin_centroids
  avg_df_training <- pred_df_training_object$df_bin
  
  eval_df_training <- generate_eval_df(data = data, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, num_bins = num_bins_vec[i], col_start = "x")
  
  eval_df_training <- eval_df_training |>
    mutate(num_bins_x = num_bins_vec[i])
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  
  
}


## Add new column with data types

eval_data_training <- eval_data_training |>
  mutate(data_type = "training")

MSE_df_2 <- eval_data_training |>
  dplyr::mutate(method = "UMAP")
```

```{r}
#| warning: false
#| echo: false

#MSE_df <- dplyr::bind_rows(MSE_df_1, MSE_df_2, MSE_df_3, MSE_df_4, MSE_df_5)
MSE_df <- MSE_df_2

MSE_df$method <- factor(MSE_df$method, levels = c("UMAP"))

## To draw with AIC
aic_plot <- ggplot(MSE_df |> dplyr::filter(data_type == "training") |> dplyr::filter(method == "UMAP"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#377eb8", "#e41a1c", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("Total number of bins")
## Effective number of bins along x-axis

mse_plot <- ggplot(MSE_df |> dplyr::filter(method == "UMAP"), aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#377eb8", "#e41a1c", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("Total number of bins")

```

```{r}
#| echo: false
#| fig-cap: "Goodness of fit statistics from different NLDR techniques applied to training S-curve dataset. What is the most effective NLDR technique to represent the original data in a 2D space? What is the effective number of bins in each NLDR technique to create a 2D model?"
#| label: fig-diagnosticpltScurve3
##| out-width: 100%

trimesh_removed_umap_s_curve_bin_mean + aic_plot + mse_plot +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='none', plot.tag = element_text(size = 8))
```

## How model perform less than and greater than the selected number of bins (UMAP with S-curve)


<!--
```{r}
#| warning: false
#| echo: false

## UMAP with n_neighbor: 7
## Prediction

UMAP_data <- read_rds("data/s_curve/s_curve_umap_7.rds")
predict_UMAP_df <- read_rds("data/s_curve/s_curve_umap_7_predict.rds")

shape_value_curve <- calculate_effective_shape_value(.data = UMAP_data,
                                                     x = UMAP1, y = UMAP2)

num_bins_vec <- 1:10 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 4), c("number_of_bins", "number_of_observations", "total_error", "total_mse"))  ## Define column names

eval_data_test <- dplyr::bind_rows(vec)[0, ]
eval_data_test <- eval_data_test |>
  dplyr::mutate_if(is.character, as.numeric)

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  pred_df_training_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_data, nldr_df_test = UMAP_data, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_training <- pred_df_training_object$pred_data
  centroid_df_training <- pred_df_training_object$df_bin_centroids
  avg_df_training <- pred_df_training_object$df_bin
  
  eval_df_training <- generate_eval_df(data = data, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, num_bins = num_bins_vec[i], col_start = "x")
  
  pred_df_test_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_data, nldr_df_test = predict_UMAP_df, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_test <- pred_df_test_object$pred_data
  centroid_df_test <- pred_df_test_object$df_bin_centroids
  avg_df_test <- pred_df_test_object$df_bin
  
  eval_df_test <- generate_eval_df(data = data, prediction_df = pred_df_test, df_bin_centroids = centroid_df_test, df_bin = avg_df_test, num_bins = num_bins_vec[i], col_start = "x")
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  eval_data_test <- dplyr::bind_rows(eval_data_test, eval_df_test)
  
  
}


## Add new column with data types

eval_data_training <- eval_data_training |>
  mutate(data_type = "training")

eval_data_test <- eval_data_test |>
  mutate(data_type = "test")

MSE_df_umap_1 <- bind_rows(eval_data_training, eval_data_test) |>
  dplyr::mutate(param = "n_neighbors: 7")
```

```{r}
#| warning: false
#| echo: false

## UMAP with n_neighbor: 15
## Prediction

UMAP_data <- read_rds("data/s_curve/s_curve_umap_15.rds")
predict_UMAP_df <- read_rds("data/s_curve/s_curve_umap_15_predict.rds")

shape_value_curve <- calculate_effective_shape_value(.data = UMAP_data,
                                                     x = UMAP1, y = UMAP2)

num_bins_vec <- 1:10 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 4), c("number_of_bins", "number_of_observations", "total_error", "total_mse"))  ## Define column names

eval_data_test <- dplyr::bind_rows(vec)[0, ]
eval_data_test <- eval_data_test |>
  dplyr::mutate_if(is.character, as.numeric)

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  pred_df_training_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_data, nldr_df_test = UMAP_data, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_training <- pred_df_training_object$pred_data
  centroid_df_training <- pred_df_training_object$df_bin_centroids
  avg_df_training <- pred_df_training_object$df_bin
  
  eval_df_training <- generate_eval_df(data = data, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, num_bins = num_bins_vec[i], col_start = "x")
  
  pred_df_test_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_data, nldr_df_test = predict_UMAP_df, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_test <- pred_df_test_object$pred_data
  centroid_df_test <- pred_df_test_object$df_bin_centroids
  avg_df_test <- pred_df_test_object$df_bin
  
  eval_df_test <- generate_eval_df(data = data, prediction_df = pred_df_test, df_bin_centroids = centroid_df_test, df_bin = avg_df_test, num_bins = num_bins_vec[i], col_start = "x")
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  eval_data_test <- dplyr::bind_rows(eval_data_test, eval_df_test)
  
  
}


## Add new column with data types

eval_data_training <- eval_data_training |>
  mutate(data_type = "training")

eval_data_test <- eval_data_test |>
  mutate(data_type = "test")

MSE_df_umap_2 <- bind_rows(eval_data_training, eval_data_test) |>
  dplyr::mutate(param = "n_neighbors: 15")
```

```{r}
#| warning: false
#| echo: false

## UMAP with n_neighbor: 32
## Prediction

UMAP_data <- read_rds("data/s_curve/s_curve_umap_32.rds")
predict_UMAP_df <- read_rds("data/s_curve/s_curve_umap_32_predict.rds")

shape_value_curve <- calculate_effective_shape_value(.data = UMAP_data,
                                                     x = UMAP1, y = UMAP2)

num_bins_vec <- 1:10 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 4), c("number_of_bins", "number_of_observations", "total_error", "total_mse"))  ## Define column names

eval_data_test <- dplyr::bind_rows(vec)[0, ]
eval_data_test <- eval_data_test |>
  dplyr::mutate_if(is.character, as.numeric)

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  pred_df_training_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_data, nldr_df_test = UMAP_data, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_training <- pred_df_training_object$pred_data
  centroid_df_training <- pred_df_training_object$df_bin_centroids
  avg_df_training <- pred_df_training_object$df_bin
  
  eval_df_training <- generate_eval_df(data = data, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, num_bins = num_bins_vec[i], col_start = "x")
  
  pred_df_test_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_data, nldr_df_test = predict_UMAP_df, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_test <- pred_df_test_object$pred_data
  centroid_df_test <- pred_df_test_object$df_bin_centroids
  avg_df_test <- pred_df_test_object$df_bin
  
  eval_df_test <- generate_eval_df(data = data, prediction_df = pred_df_test, df_bin_centroids = centroid_df_test, df_bin = avg_df_test, num_bins = num_bins_vec[i], col_start = "x")
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  eval_data_test <- dplyr::bind_rows(eval_data_test, eval_df_test)
  
  
}


## Add new column with data types

eval_data_training <- eval_data_training |>
  mutate(data_type = "training")

eval_data_test <- eval_data_test |>
  mutate(data_type = "test")

MSE_df_umap_3 <- bind_rows(eval_data_training, eval_data_test) |>
  dplyr::mutate(param = "n_neighbors: 32")
```

```{r}
#| warning: false
#| echo: false

## UMAP with n_neighbor: 50
## Prediction

UMAP_data <- read_rds("data/s_curve/s_curve_umap.rds")
predict_UMAP_df <- read_rds("data/s_curve/s_curve_umap_predict.rds")

shape_value_curve <- calculate_effective_shape_value(.data = UMAP_data,
                                                     x = UMAP1, y = UMAP2)

num_bins_vec <- 1:10 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 4), c("number_of_bins", "number_of_observations", "total_error", "total_mse"))  ## Define column names

eval_data_test <- dplyr::bind_rows(vec)[0, ]
eval_data_test <- eval_data_test |>
  dplyr::mutate_if(is.character, as.numeric)

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  pred_df_training_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_data, nldr_df_test = UMAP_data, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_training <- pred_df_training_object$pred_data
  centroid_df_training <- pred_df_training_object$df_bin_centroids
  avg_df_training <- pred_df_training_object$df_bin
  
  eval_df_training <- generate_eval_df(data = data, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, num_bins = num_bins_vec[i], col_start = "x")
  
  pred_df_test_object <- predict_hex_id(training_data = training_data, nldr_df = UMAP_data, nldr_df_test = predict_UMAP_df, num_bins = num_bins_vec[i], shape_val = shape_value_curve, x = "UMAP1", y = "UMAP2", col_start = "x")
  pred_df_test <- pred_df_test_object$pred_data
  centroid_df_test <- pred_df_test_object$df_bin_centroids
  avg_df_test <- pred_df_test_object$df_bin
  
  eval_df_test <- generate_eval_df(data = data, prediction_df = pred_df_test, df_bin_centroids = centroid_df_test, df_bin = avg_df_test, num_bins = num_bins_vec[i], col_start = "x")
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  eval_data_test <- dplyr::bind_rows(eval_data_test, eval_df_test)
  
  
}


## Add new column with data types

eval_data_training <- eval_data_training |>
  mutate(data_type = "training")

eval_data_test <- eval_data_test |>
  mutate(data_type = "test")

MSE_df_umap_4 <- bind_rows(eval_data_training, eval_data_test) |>
  dplyr::mutate(param = "n_neighbors: 50")
```


```{r}
#| warning: false
#| echo: false

MSE_df_umap <- dplyr::bind_rows(MSE_df_umap_1, MSE_df_umap_2, MSE_df_umap_3, MSE_df_umap_4)
MSE_df_umap$param <- factor(MSE_df_umap$param, levels = c("n_neighbors: 7", "n_neighbors: 15", "n_neighbors: 32", "n_neighbors: 50"))

## To draw with AIC
aic_plot_param <- ggplot(MSE_df_umap |> dplyr::filter(data_type == "training"), aes(x = number_of_bins,
                                                                         y = total_error,
                                                                         color = param
)) +
  geom_point() +
  geom_line() +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.title = element_blank(), legend.text = element_text(size=7), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_color_manual(values = c("#8dd3c7", "#a65628", "#f781bf", "#999999")) +
  ylab("AIC") +
  xlab("Total number of bins")
## Effective number of bins along x-axis

mse_plot_param_training <- ggplot(MSE_df_umap |> dplyr::filter(data_type == "training"), aes(x = number_of_bins,
                               y = total_mse,
                               color = param
)) +
  geom_point() +
  geom_line() +
  theme_light() +
  theme(legend.title = element_blank(), legend.text = element_text(size=7), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_color_manual(values = c("#8dd3c7", "#a65628", "#f781bf", "#999999")) +
  ylab("MSE") +
  xlab("Total number of bins")

mse_plot_param_test <- ggplot(MSE_df_umap |> dplyr::filter(data_type == "test"), aes(x = number_of_bins,
                                                                                             y = total_mse,
                                                                                             color = param
)) +
  geom_point() +
  geom_line() +
  theme_light() +
  theme(legend.title = element_blank(), legend.text = element_text(size=7), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_color_manual(values = c("#8dd3c7", "#a65628", "#f781bf", "#999999")) +
  ylab("MSE") +
  xlab("Total number of bins")

```

```{r}
#| echo: false
#| fig-cap: "Goodness of fit statistics from different n_neighbors parameter of UMAP applied to training S-curve dataset. What is the best parameter choice in UMAP to represent the original data in 2D?"
#| label: fig-diagnosticpltDiffParam
#| out-width: 100%

aic_plot_param + mse_plot_param_training + mse_plot_param_test  +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 3) &
  theme(legend.position='bottom', plot.tag = element_text(size = 8))
```
-->


<!--model for S-curve with 5 methods-->
<!--
```{r}
#| warning: false
#| echo: false

## Import data

tSNE_s_curve <- read_rds("data/s_curve/s_curve_tsne_27.rds")
UMAP_s_curve <- read_rds("data/s_curve/s_curve_umap.rds")
PHATE_s_curve <- read_rds("data/s_curve/s_curve_phate.rds")
TriMAP_s_curve <- read_rds("data/s_curve/s_curve_trimap.rds")
PaCMAP_s_curve <- read_rds("data/s_curve/s_curve_pacmap.rds")


## tSNE

num_bins_tsne_s_curve <- 8
shape_val_tsne_s_curve <- calculate_effective_shape_value(.data = tSNE_s_curve,
                                                          x = tSNE1, y = tSNE2) ## 1.259938
## To extract bin centroids
hexbin_data_object_tsne_s_curve <- extract_hexbin_centroids(nldr_df = tSNE_s_curve, num_bins = num_bins_tsne_s_curve, shape_val = shape_val_tsne_s_curve, x = tSNE1, y = tSNE2)

df_bin_centroids_tsne_s_curve <- hexbin_data_object_tsne_s_curve$hexdf_data

tSNE_data_with_hb_id_s_curve <- tSNE_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_tsne_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_tsne_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), tSNE_data_with_hb_id_s_curve)

## Averaged on high-D
df_bin_tsne_s_curve <- avg_highD_data(.data = df_all_tsne_s_curve)

## Triangulate bin centroids
tr1_object_tsne_s_curve <- triangulate_bin_centroids(df_bin_centroids_tsne_s_curve, x, y)
tr_from_to_df_tsne_s_curve <- generate_edge_info(triangular_object = tr1_object_tsne_s_curve)

# ggplot(df_bin_centroids_tsne_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_tsne_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_tsne_s_curve <- cal_2d_dist(.data = tr_from_to_df_tsne_s_curve)

## To find the benchmark value
benchmark_tsne_s_curve <- find_benchmark_value(.data = distance_tsne_s_curve, distance_col = distance)

# colour_long_edges(.data = distance_tsne_s_curve, benchmark_value = benchmark_tsne_s_curve,
#                   triangular_object = tr1_object_tsne_s_curve, distance_col = distance)

trimesh_removed_tsne_s_curve <- remove_long_edges(.data = distance_tsne_s_curve, benchmark_value = benchmark_tsne_s_curve,
                                                  triangular_object = tr1_object_tsne_s_curve, distance_col = distance)

trimesh_removed_tsne_s_curve <- trimesh_removed_tsne_s_curve +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 

# tour_tsne_s_curve <- show_langevitour(df_all_tsne_s_curve, df_bin_tsne_s_curve, df_bin_centroids_tsne_s_curve, benchmark_value = benchmark_tsne_s_curve, distance = distance_tsne_s_curve, distance_col = distance)



## UMAP

num_bins_umap_s_curve <- 6
shape_val_umap_s_curve <- calculate_effective_shape_value(.data = UMAP_s_curve,
                                                          x = UMAP1, y = UMAP2) ## 1.259938
## To extract bin centroids
hexbin_data_object_umap_s_curve <- extract_hexbin_centroids(nldr_df = UMAP_s_curve, num_bins = num_bins_umap_s_curve, shape_val = shape_val_umap_s_curve, x = UMAP1, y = UMAP2)

df_bin_centroids_umap_s_curve <- hexbin_data_object_umap_s_curve$hexdf_data

UMAP_data_with_hb_id_s_curve <- UMAP_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_umap_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_umap_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), UMAP_data_with_hb_id_s_curve)

## Averaged on high-D
df_bin_umap_s_curve <- avg_highD_data(.data = df_all_umap_s_curve)

## Triangulate bin centroids
tr1_object_umap_s_curve <- triangulate_bin_centroids(df_bin_centroids_umap_s_curve, x, y)
tr_from_to_df_umap_s_curve <- generate_edge_info(triangular_object = tr1_object_umap_s_curve)

# ggplot(df_bin_centroids_umap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_umap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_umap_s_curve <- cal_2d_dist(.data = tr_from_to_df_umap_s_curve)

## To find the benchmark value
benchmark_umap_s_curve <- find_benchmark_value(.data = distance_umap_s_curve, distance_col = distance)

# colour_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve,
#                   triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_removed_umap_s_curve <- remove_long_edges(.data = distance_umap_s_curve, benchmark_value = benchmark_umap_s_curve,
                                     triangular_object = tr1_object_umap_s_curve, distance_col = distance)

trimesh_removed_umap_s_curve <- trimesh_removed_umap_s_curve +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)

# tour_umap_s_curve <- show_langevitour(df_all_umap_s_curve, df_bin_umap_s_curve, df_bin_centroids_umap_s_curve, benchmark_value = benchmark_umap_s_curve, distance = distance_umap_s_curve, distance_col = distance)


## TriMAP

num_bins_trimap_s_curve <- 6
shape_val_trimap_s_curve <- calculate_effective_shape_value(.data = TriMAP_s_curve,
                                                            x = TriMAP1, y = TriMAP2) ## 1.259938
## To extract bin centroids
hexbin_data_object_trimap_s_curve <- extract_hexbin_centroids(nldr_df = TriMAP_s_curve, num_bins = num_bins_trimap_s_curve, shape_val = shape_val_trimap_s_curve, x = TriMAP1, y = TriMAP2)

df_bin_centroids_trimap_s_curve <- hexbin_data_object_trimap_s_curve$hexdf_data

TriMAP_data_with_hb_id_s_curve <- TriMAP_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_trimap_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_trimap_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), TriMAP_data_with_hb_id_s_curve)

## Averaged on high-D
df_bin_trimap_s_curve <- avg_highD_data(.data = df_all_trimap_s_curve)

## Triangulate bin centroids
tr1_object_trimap_s_curve <- triangulate_bin_centroids(df_bin_centroids_trimap_s_curve, x, y)
tr_from_to_df_trimap_s_curve <- generate_edge_info(triangular_object = tr1_object_trimap_s_curve)

# ggplot(df_bin_centroids_trimap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_trimap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_trimap_s_curve <- cal_2d_dist(.data = tr_from_to_df_trimap_s_curve)

## To find the benchmark value
benchmark_trimap_s_curve <- find_benchmark_value(.data = distance_trimap_s_curve, distance_col = distance)

# colour_long_edges(.data = distance_trimap_s_curve, benchmark_value = benchmark_trimap_s_curve,
#                   triangular_object = tr1_object_trimap_s_curve, distance_col = distance)

trimesh_removed_trimap_s_curve <- remove_long_edges(.data = distance_trimap_s_curve, benchmark_value = benchmark_trimap_s_curve,
                                                    triangular_object = tr1_object_trimap_s_curve, distance_col = distance)

trimesh_removed_trimap_s_curve <- trimesh_removed_trimap_s_curve +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.25) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'd', x = Inf, y = Inf, hjust = 1.5, vjust = 1.5, size = 3) 

# tour_trimap_s_curve <- show_langevitour(df_all_trimap_s_curve, df_bin_trimap_s_curve, df_bin_centroids_trimap_s_curve, benchmark_value = benchmark_trimap_s_curve, distance = distance_trimap_s_curve, distance_col = distance)



## PacMAP

num_bins_pacmap_s_curve <- 10
shape_val_pacmap_s_curve <- calculate_effective_shape_value(.data = PaCMAP_s_curve,
                                                            x = PaCMAP1, y = PaCMAP2) ## 1.259938
## To extract bin centroids
hexbin_data_object_pacmap_s_curve <- extract_hexbin_centroids(nldr_df = PaCMAP_s_curve, num_bins = num_bins_pacmap_s_curve, shape_val = shape_val_pacmap_s_curve, x = PaCMAP1, y = PaCMAP2)

df_bin_centroids_pacmap_s_curve <- hexbin_data_object_pacmap_s_curve$hexdf_data

PaCMAP_data_with_hb_id_s_curve <- PaCMAP_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_pacmap_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_pacmap_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), PaCMAP_data_with_hb_id_s_curve)

## Averaged on high-D
df_bin_pacmap_s_curve <- avg_highD_data(.data = df_all_pacmap_s_curve)

## Triangulate bin centroids
tr1_object_pacmap_s_curve <- triangulate_bin_centroids(df_bin_centroids_pacmap_s_curve, x, y)
tr_from_to_df_pacmap_s_curve <- generate_edge_info(triangular_object = tr1_object_pacmap_s_curve)

# ggplot(df_bin_centroids_pacmap_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_pacmap_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_pacmap_s_curve <- cal_2d_dist(.data = tr_from_to_df_pacmap_s_curve)

## To find the benchmark value
benchmark_pacmap_s_curve <- find_benchmark_value(.data = distance_pacmap_s_curve, distance_col = distance)

# colour_long_edges(.data = distance_pacmap_s_curve, benchmark_value = benchmark_pacmap_s_curve,
#                   triangular_object = tr1_object_pacmap_s_curve, distance_col = distance)

trimesh_removed_pacmap_s_curve <- remove_long_edges(.data = distance_pacmap_s_curve, benchmark_value = benchmark_pacmap_s_curve,
                                     triangular_object = tr1_object_pacmap_s_curve, distance_col = distance)

trimesh_removed_pacmap_s_curve <- trimesh_removed_pacmap_s_curve +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'e', x = Inf, y = Inf, hjust = 1.5, vjust = 1.5, size = 3)

# tour_pacmap_s_curve <- show_langevitour(df_all_pacmap_s_curve, df_bin_pacmap_s_curve, df_bin_centroids_pacmap_s_curve, benchmark_value = benchmark_pacmap_s_curve, distance = distance_pacmap_s_curve, distance_col = distance)

## PHATE

num_bins_phate_s_curve <- 8
shape_val_phate_s_curve <- calculate_effective_shape_value(.data = PHATE_s_curve,
                                                           x = PHATE1, y = PHATE2) ## 1.259938
## To extract bin centroids
hexbin_data_object_phate_s_curve <- extract_hexbin_centroids(nldr_df = PHATE_s_curve, num_bins = num_bins_phate_s_curve, shape_val = shape_val_phate_s_curve, x = PHATE1, y = PHATE2)

df_bin_centroids_phate_s_curve <- hexbin_data_object_phate_s_curve$hexdf_data

## Identify bins with low-density
identify_rm_bins <- find_low_density_hexagons(df_bin_centroids_phate_s_curve, num_bins_phate_s_curve, benchmark_rm_hex = 0.06)

df_bin_centroids_phate_s_curve <- df_bin_centroids_phate_s_curve |>
  filter(!(hexID %in% identify_rm_bins))

PHATE_data_with_hb_id_s_curve <- PHATE_s_curve |>
  dplyr::mutate(hb_id = hexbin_data_object_phate_s_curve$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_phate_s_curve <- dplyr::bind_cols(training_data |> dplyr::select(-ID), PHATE_data_with_hb_id_s_curve)

## Averaged on high-D
df_bin_phate_s_curve <- avg_highD_data(.data = df_all_phate_s_curve)

## Triangulate bin centroids
tr1_object_phate_s_curve <- triangulate_bin_centroids(df_bin_centroids_phate_s_curve, x, y)
tr_from_to_df_phate_s_curve <- generate_edge_info(triangular_object = tr1_object_phate_s_curve)

# ggplot(df_bin_centroids_phate_s_curve, aes(x = x, y = y)) +
#   geom_segment(data = tr_from_to_df_phate_s_curve, aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) +
#   geom_point(size = 2, colour = "#33a02c") +
#   coord_equal()


## Compute 2D distances
distance_phate_s_curve <- cal_2d_dist(.data = tr_from_to_df_phate_s_curve)

## To find the benchmark value
benchmark_phate_s_curve <- find_benchmark_value(.data = distance_phate_s_curve, distance_col = distance)

# colour_long_edges(.data = distance_phate_s_curve, benchmark_value = benchmark_phate_s_curve,
#                   triangular_object = tr1_object_phate_s_curve, distance_col = distance)

trimesh_removed_phate_s_curve <- remove_long_edges(.data = distance_phate_s_curve, benchmark_value = benchmark_phate_s_curve,
                                                   triangular_object = tr1_object_phate_s_curve, distance_col = distance)

trimesh_removed_phate_s_curve <- trimesh_removed_phate_s_curve +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'c', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 

# tour_phate_s_curve <- show_langevitour(df_all_phate_s_curve, df_bin_phate_s_curve, df_bin_centroids_phate_s_curve, benchmark_value = benchmark_phate_s_curve, distance = distance_phate_s_curve, distance_col = distance)

```


```{r}
#| warning: false
#| echo: false
#| label: fig-modelScurve
#| fig-cap: Is there a good model to represent the original data in 2D space or are they all providing equivalent information?, (a) Model in the 2D space with tSNE (<https://youtu.be/uy9SkAo6gAE>), (b) Model in the 2D space with UMAP (<https://youtu.be/0MJDhHrh_Ug>), (c) Model in the 2D space with PHATE (<https://youtu.be/HbVv0uy0QWk>), (d) Model in the 2D space with TriMAP (<https://youtu.be/2OGwipAjzc8>), and (e) Model in the 2D space with PaCMAP (<https://youtu.be/pkokI8d-cBk>).
#| out-width: 100%

trimesh_removed_tsne_s_curve + trimesh_removed_umap_s_curve + trimesh_removed_phate_s_curve + trimesh_removed_trimap_s_curve + trimesh_removed_pacmap_s_curve +
  #plot_annotation(tag_levels = 'a') +
  plot_layout(ncol = 5) &
  theme(legend.position='none', plot.tag = element_text(size = 8))
```
-->

<!--
### Single-Cell Tagged Reverse Transcription sequencing data of mouse

The Zeisel mouse brain dataset, obtained through Spatial Transcriptomics (STRT-Seq). Within this dataset, information is collected from a substantial 2,816 individual mouse brain cells. Each of these cells acts as a molecular snapshot, capturing the distinctive genetic activity within various cell types. This diversity spans neurons, glial cells, and other essential components of the brain, offering a comprehensive view of the cellular tapestry.

What makes this dataset particularly valuable is its ability to shed light on the spatial distribution of cells. Researchers can explore how gene expression patterns vary across different regions of the mouse brain, unlocking insights into the functional specialization of these regions and the intricate networks that underpin neural processes.

```{r}
#| warning: false
#| echo: false

## Import data
df_2 <- read_rds("data/zeisel/zeisel.rds")
training_data_1 <- read_rds("data/zeisel/zeisel_training.rds")
test_1 <- read_rds("data/zeisel/zeisel_test.rds")

tSNE_zeisel <- read_rds("data/zeisel/zeisel_tsne_30.rds")
UMAP_zeisel <- read_rds("data/zeisel/zeisel_umap.rds")
PHATE_zeisel <- read_rds("data/zeisel/zeisel_phate.rds")
TriMAP_zeisel <- read_rds("data/zeisel/zeisel_trimap.rds")
PaCMAP_zeisel <- read_rds("data/zeisel/zeisel_pacmap.rds")

## Visualise embeddings

plot_list1_zeisel <- plot_tSNE_2D(tSNE_zeisel) + #ggtitle("(a)") + 
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)


plot_list2_zeisel <- plot_UMAP_2D(UMAP_zeisel) + #ggtitle("(b)") + 
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'b', x = Inf, y = Inf, hjust = 1.5, vjust = 1.5, size = 3)


plot_list3_zeisel <- plot_PHATE_2D(PHATE_zeisel) + #ggtitle("(c)") + 
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'c', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)


plot_list4_zeisel <- plot_TriMAP_2D(TriMAP_zeisel) + #ggtitle("(d)") + 
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'd', x = Inf, y = Inf, hjust = 1.5, vjust = 1.5, size = 3)

plot_list5_zeisel <- plot_PaCMAP_2D(PaCMAP_zeisel) + #ggtitle("(e)") + 
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'e', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)
```

```{r}
#| echo: false
#| fig-cap: "2D layouts from different NLDR techniques applied for the training Zeisel mouse brain dataset: (a) tSNE (perplexity = 30), (b) UMAP (n_neighbors = 15), (c) PHATE (knn = 5), (d) TriMAP (n_inliers = 5, n_outliers = 4, n_random = 3), and (e) PaCMAP (n_neighbors = 10, init = random, MN_ratio = 0.9, FP_ratio = 2). Is there a best representation of the original data or are they all providing  equivalent information?"
#| label: fig-nldervis5Mouse
#| out-width: 100%

plot_list1_zeisel + plot_list2_zeisel + plot_list3_zeisel + plot_list4_zeisel + plot_list5_zeisel +
  plot_layout(ncol=5)
```


```{r}
#| warning: false
#| echo: false

MSE_df_zei <- read_rds("data/zeisel/summary_zei.rds")
MSE_df_zei$method <- factor(MSE_df_zei$method, levels = c("tSNE", "UMAP", "PHATE", "TriMAP", "PaCMAP"))

## To draw with AIC
aic_plot_zei <- ggplot(MSE_df_zei |> dplyr::filter(data_type == "training"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("Total number of bins")
## Effective number of bins along x-axis

mse_plot_zei <- ggplot(MSE_df_zei, aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
  theme_light() +
  theme(legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("Total number of bins")

```

```{r}
#| echo: false
#| fig-cap: Goodness of fit statistics from different NLDR techniques applied to training Zeisel mouse brain dataset. What is the best NLDR technique to represent the original data in 2D?
#| label: fig-diagnosticpltZEI
#| out-width: 100%

aic_plot_zei + mse_plot_zei +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='bottom', plot.tag = element_text(size = 8))
```

### Retina dataset

Human retina: https://www.ebi.ac.uk/biostudies/arrayexpress/studies/E-MTAB-7316

https://www.cell.com/cms/10.1016/j.cell.2015.05.002/attachment/fd52950c-fd35-401a-9e60-ca7588ef9001/mmc1.pdf

https://www.cell.com/fulltext/S0092-8674(15)00549-8#app3

32 PCs
tSNE (perplexity 30)

### Kang dataset

For the Kang lupus dataset (29), we obtained 16 cell types based on clustering of the Festem-
selected genes (Fig. 4E and Fig. S10, S11), including 2 fine cell types that were often missed by
other methods. The 2 cell types were IFNhi CD14+ monocytes with high expression of type I
interferon-related (IFN) genes, and HSP+ CD4 T cells with up-regulated heat-
shock-protein-related (HSP) genes. The HSP+ CD4 T cells might result from
cryopreservation and thawing of T cells (37). Other than devianceFS, other available methods
could not identify these HSP+ CD4 T cells (Fig. S11).

```{r}
#| warning: false
#| echo: false

## Import data
#df_2 <- read_rds("data/pbmc/pbmc.rds")
# training_data_1 <- read_rds("data/pbmc/pbmc_3k_festem/pbmc_pca_50.rds")
# training_data_1 <- training_data_1[, 1:25]
#test_1 <- read_rds("data/pbmc/pbmc_test.rds")

#tSNE_pbmc <- read_rds("data/pbmc/pbmc_tsne_30.rds")
tSNE_kang <- read_rds("data/kang/kang_tsne.rds") |>
  mutate(cell_label = if_else(cell_label %in% c("0", "3", "5"), "0", cell_label))
# PHATE_pbmc <- read_rds("data/pbmc/pbmc_phate.rds")
# TriMAP_pbmc <- read_rds("data/pbmc/pbmc_trimap.rds")
# PaCMAP_pbmc <- read_rds("data/pbmc/pbmc_pacmap.rds")

#load("data/pbmc/pbmc_3k_festem/pbmc3k_label.RData")

## Visualise embeddings

# plot_list1_pbmc <- plot_tSNE_2D(tSNE_pbmc) + #ggtitle("(a)") + 
#   theme_linedraw() +
#   theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
#         axis.title.x = element_blank(), axis.title.y = element_blank(),
#         axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#         axis.text.y = element_blank(), axis.ticks.y = element_blank(),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
#   annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)

class_avg <- tSNE_kang |>
  group_by(cell_label) |>
  summarise(
    tSNE1 = median(tSNE1),
    tSNE2 = median(tSNE2)
  ) |>
  mutate(cell_label = as.numeric(cell_label)) |>
  arrange(cell_label)

class_avg$cell_label <- as.factor(class_avg$cell_label)

levels(class_avg$cell_label) <- c("CD14 Monocyte", "CD4 \n Memory T", "CD4 Naive T", "CD16 Monocyte", "B", "T Activated", "CD8 T", "NK", "DC", "B \nActivated", "T cell:\nmonocyte \nComplex", "HSP+ CD4 T", "IFN^hi CD14 \n Monocyte", "CD34 \n Progenitors", "pDC")

plot_list2_kang <- tSNE_kang |>
    ggplot(aes(x = tSNE1,
               y = tSNE2, color = cell_label))+
    geom_point(alpha=0.5) +
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(legend.position = "none", plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#b15928", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#6a3d9a", "#ff7f00", "#cab2d6", "#fdbf6f", "#ffff99", "#a6cee3", "#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#000000", "#bdbdbd")) +
  geom_text(aes(x=tSNE1,y = tSNE2,label = cell_label), data = class_avg,inherit.aes = F, color = "black",fontface = "bold",size = 2) #+
  # guides(color = guide_legend(title = "Cell type"),
  #        color = guide_legend(nrow = 3)) #+
  # annotate(geom = 'text', label = 'b', x = Inf, y = Inf, hjust = 1.5, vjust = 1.5, size = 3)


# plot_list3_pbmc <- plot_PHATE_2D(PHATE_pbmc) + #ggtitle("(c)") + 
#   theme_linedraw() +
#   theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
#         axis.title.x = element_blank(), axis.title.y = element_blank(),
#         axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#         axis.text.y = element_blank(), axis.ticks.y = element_blank(),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
#   annotate(geom = 'text', label = 'c', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)


# plot_list4_pbmc <- plot_TriMAP_2D(TriMAP_pbmc) + #ggtitle("(d)") + 
#   theme_linedraw() +
#   theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
#         axis.title.x = element_blank(), axis.title.y = element_blank(),
#         axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#         axis.text.y = element_blank(), axis.ticks.y = element_blank(),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
#   annotate(geom = 'text', label = 'd', x = Inf, y = Inf, hjust = 1.5, vjust = 1.5, size = 3)
# 
# plot_list5_pbmc <- plot_PaCMAP_2D(PaCMAP_pbmc) + #ggtitle("(e)") + 
#   theme_linedraw() +
#   theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5), 
#         axis.title.x = element_blank(), axis.title.y = element_blank(),
#         axis.text.x = element_blank(), axis.ticks.x = element_blank(),
#         axis.text.y = element_blank(), axis.ticks.y = element_blank(),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
#   annotate(geom = 'text', label = 'e', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)
```

```{r}
#| echo: false
#| fig-cap: "2D layout from tSNE (perplexity = 30) applied for the Kang dataset. Is this a best representation of the original data?"
#| label: fig-nlderviskangtSNE


plot_list2_kang

#  plot_list1_pbmc + plot_list3_pbmc + plot_list4_pbmc + plot_list5_pbmc +
#   plot_layout(ncol=5) #| out-width: 100%

# 2D layouts from different NLDR techniques applied for the training PBMC dataset: (a) tSNE (perplexity = 30), (b) UMAP (n_neighbors = 15), (c) PHATE (knn = 5), (d) TriMAP (n_inliers = 5, n_outliers = 4, n_random = 3), and (e) PaCMAP (n_neighbors = 10, init = random, MN_ratio = 0.9, FP_ratio = 2). Is there a best representation of the original data or are they all providing  equivalent information?
```
-->

<!--
### Single-cell RNA-seq data of human

https://github.com/XiDsLab/Festem_paper/tree/main

@Chen2023

https://satijalab.org/seurat/articles/pbmc3k_tutorial.html
https://www.cell.com/fulltext/S0092-8674(15)00549-8

In the field of single-cell studies, a common analysis task involves clustering to identify groups of cells with similar expression profiles. Analysts often turn to NLDR techniques to verify and identify these clusters and explore developmental trajectories (e.g., example 1). In clustering workflows, the main objective is to verify the existence of clusters and subsequently identify them as specific cell types by examining the expression of "known" marker genes. In this context, a "faithful" embedding should ideally preserve the topology of the data, ensuring that cells corresponding to the same cell type are situated close to the high-dimensional space.
  
To begin our analysis, we installed the Peripheral Blood Mononuclear Cells (pbmc) data set obtained from 10x Genomics using the `SeuratData` R package [@Rahul2019], which facilitates the distribution of data sets in the form of Seurat objects [@Yuhan2021]. This data set contains 13,714 features across 2,700 samples within a single assay. The active assay is RNA, with 13,714 features representing different gene expressions. After loading the data set, we obtained the principal components (PCs) and assessed the variance explained by each PC. Based on this evaluation, we selected seven PCs, representing approximately 50% of the variance in gene expression, for further analysis.
  
Next, we employed the UMAP technique with default parameter settings. As illustrated in @fig-pbmc, the cell types B and Platelet are well-separated in the UMAP layout. Moreover, CD14+ Mono, FCGR3A+ Mono, and DC form a distinct cluster, while Naive CD4 T, NK, Memory CD4 T, and CD8 T are grouped together in another cluster. The values utilized to construct the smooth low-dimensional manifold are presented in @tbl-table02. The linked video, demonstrating the tour with the model, showcases the generation of a smooth surface for this application, enabling a comprehensive exploration of the data's structure and relationships (see @fig-pbmc_sc).




```{r}
#| warning: false
#| echo: false

MSE_df_pbmc <- read_rds("data/pbmc/summary_pbmc.rds")
MSE_df_pbmc$method <- factor(MSE_df_pbmc$method, levels = c("tSNE", "UMAP", "PHATE", "TriMAP", "PaCMAP"))


## To draw with AIC
aic_plot_pbmc <- ggplot(MSE_df_pbmc |> dplyr::filter(data_type == "training"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("Total number of bins")
## Effective number of bins along x-axis

mse_plot_pbmc <- ggplot(MSE_df_pbmc, aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
  theme_light() +
  theme(legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("Total number of bins")

```

```{r}
#| echo: false
#| fig-cap: Goodness of fit statistics from different NLDR techniques applied to training PBMC dataset. What is the best NLDR technique to represent the original data in 2D?
#| label: fig-diagnosticpltPBMC
#| out-width: 100%

aic_plot_pbmc + mse_plot_pbmc +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='bottom', plot.tag = element_text(size = 8))
```

### HARPS GTO sample dataset 

@Anders2018

- In 2D, there are two well-separated clusters, but the clusters are really close

- One cluster have a sparse data space within the cluster

- There is a line in right corner of the structure that is not connected any other trimesh points. This line create a long edge in high-D space.

- In high-D view, the clusters having some non-linearity patter, which is also not captured in tSNE. Therefore, this is not a good choice. Also, the two clusters are really near to each other and can't see any separation. Also continuity of the structure. Long edges are presence also.

- The parameter is, in a sense, a guess about the number of close neighbors each point has.

- Num bins along the x-axis = 43, shape parameter = 0.4466309

```{r}
#| warning: false
#| echo: false

error_df <- read_csv("data/harps/error_harps_tsne.csv", col_names = FALSE)

error_df <- error_df |>
  mutate(X2 = round(X2/100, 2),
         X1 = as.integer(X1)) |>
  arrange(X2)

colnames(error_df) <- c("perplexity", "error (x 100)")


kable(error_df, caption = "errors for different parameter combinations", label = "tbl-errordiffcombharps") |>
  #xtable2kable() |>
  kable_styling(latex_options = c("striped", "HOLD_position"), position = "center", full_width = FALSE) |>
  row_spec(0, bold = TRUE) |>
  row_spec(3, bold=T, color = "red")
```

<!-- Author suggestion-->
```{r}
#| warning: false
#| echo: false

tSNE_data_harps <- read_rds("data/harps/harps_tsne_40.rds") 

plot_list2_harps <- tSNE_data_harps |>
    ggplot(aes(x = tSNE1,
               y = tSNE2, color = cluster))+
    geom_point(alpha=0.5) +
    #coord_cartesian(xlim = c(-25, 25), ylim = c(-12, 12)) +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#b15928", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#6a3d9a", "#ff7f00", "#cab2d6", "#fdbf6f", "#ffff99", "#a6cee3", "#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#000000", "#bdbdbd")) +
  guides(color = guide_legend(title = "cluster"),
         color = guide_legend(nrow = 3)) +
 annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)

```

```{r}
#| warning: false
#| echo: false

## Import data
training_data_1 <- read_rds("data/harps/harps_data.rds")
training_data_1 <- training_data_1 |>
  mutate(ID = 1:NROW(training_data_1))

clusters <- training_data_1$cluster
select_names <-  names(training_data_1)[-c(18, length(training_data_1))]

training_data_1 <- training_data_1 |> select(-cluster)
names(training_data_1) <- append(paste0("x", 1:17), "ID")

tSNE_data_harps <- tSNE_data_harps |>
  select(tSNE1, tSNE2) |>
  mutate(ID = 1:NROW(tSNE_data_harps))


## tSNE
## Prediction

shape_val_tsne_harps <- calculate_effective_shape_value(.data = tSNE_data_harps,
                                                      x = tSNE1, y = tSNE2)

num_bins_vec <- 1:21 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 5), c("number_of_bins", "number_of_observations", "total_error", "total_mse", "num_bins_x"))  ## Define column names

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  model_object <- fit_high_d_model(training_data = training_data_1, nldr_df_with_id = tSNE_data_harps, x = "tSNE1", y = "tSNE2", num_bins_x = num_bins_vec[i], shape_val = shape_val_tsne_harps,
                             is_bin_centroid = TRUE,
                             is_rm_lwd_hex = FALSE,
                             benchmark_to_rm_lwd_hex = NA,
                             is_avg_high_d = TRUE, column_start_text = "x")
  
  centroid_df_training <- model_object$df_bin_centroids
  avg_df_training <- model_object$df_bin
  
  pred_df_training <- predict_2d_embeddings(test_data = training_data_1, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, type_NLDR = "tSNE")
  
  eval_df_training <- generate_eval_df(data = training_data_1, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, col_start = "x")
  
  eval_df_training <- eval_df_training |>
    mutate(num_bins_x = num_bins_vec[i])
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  
  
}


## Add new column with data types

MSE_df_harps <- eval_data_training |>
  dplyr::mutate(data_type = "training",
                method = "tSNE")
```

```{r}
#| warning: false
#| echo: false

## To draw with AIC
aic_plot_harps <- ggplot(MSE_df_harps |> dplyr::filter(data_type == "training") |> dplyr::filter(method == "tSNE"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = 120, linetype="dashed", 
                color = "black", size=0.5) +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#e41a1c","#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("total number of bins")
## Effective number of bins along x-axis

mse_plot_harps <- ggplot(MSE_df_harps |> dplyr::filter(method == "tSNE"), aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
   geom_vline(xintercept = 120, linetype="dashed", 
                color = "black", size=0.5) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#e41a1c","#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("total number of bins")

```

```{r}
#| echo: false
#| fig-cap: "Goodness of fit statistics from UMAP applied to training S-curve dataset. What is the effective number of bins in each NLDR technique to create a 2D model? The MSE plot have a steep slope at the beginning, indicating that a smaller number of bins causes a larger amount of error. Then, the slope gradually declines or level off, indicating that a higher number of bins generates a smaller error. Using the elbow method, when the total number of bins is set to 144, the slope of the Mean Squared Error (MSE) plot experiences a sudden and noticeable change, resembling an elbow-like shape. This point indicates that adding less bins does not enough to capture the data structure."
#| label: fig-diagnosticpltHARPS
##| out-width: 100%
#| fig-pos: H

aic_plot_harps + mse_plot_harps +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='none', plot.tag = element_text(size = 8))
```

```{r}
#| warning: false
#| echo: false


### tSNE

num_bins_tsne_harps <- calculate_effective_x_bins(.data = tSNE_data_harps, x = "tSNE1",
                                                cell_area = 1) #43

num_bins_tsne_harps <- 14

shape_val_tsne_harps <- calculate_effective_shape_value(.data = tSNE_data_harps,
                                                      x = "tSNE1", y = "tSNE2")
## To extract bin centroids
hexbin_data_object_tsne_harps <- extract_hexbin_centroids(nldr_df = tSNE_data_harps, num_bins = num_bins_tsne_harps, shape_val = shape_val_tsne_harps, x = "tSNE1", y = "tSNE2")

df_bin_centroids_tsne_harps <- hexbin_data_object_tsne_harps$hexdf_data

#num_non_empty_bins_harps <- df_bin_centroids_tsne_harps$hexID |> length()

## Identify bins with low-density
# identify_rm_bins <- find_low_density_hexagons(df_bin_centroids_tsne_harps, num_bins_tsne_harps, benchmark_rm_hex = 0.01)
# 
# df_bin_centroids_tsne_harps <- df_bin_centroids_tsne_harps |>
#   filter(!(hexID %in% identify_rm_bins))

tSNE_data_with_hb_id_harps <- tSNE_data_harps |>
  dplyr::mutate(hb_id = hexbin_data_object_tsne_harps$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_tsne_harps <- dplyr::bind_cols(training_data_1 |> dplyr::select(-ID), tSNE_data_with_hb_id_harps)

## Averaged on high-D
df_bin_tsne_harps <- avg_highD_data(.data = df_all_tsne_harps)

## Triangulate bin centroids
tr1_object_tsne_harps <- triangulate_bin_centroids(df_bin_centroids_tsne_harps, x, y)
tr_from_to_df_tsne_harps <- generate_edge_info(triangular_object = tr1_object_tsne_harps)

## Compute 2D distances
distance_tsne_harps <- cal_2d_dist(.data = tr_from_to_df_tsne_harps)

## To find the benchmark value
benchmark_tsne_harps <- find_benchmark_value(.data = distance_tsne_harps, distance_col = "distance")
benchmark_tsne_harps <- 5

# distance_plot <- plot_dist(distance_tsne_harps) +
#   #ggtitle("(b)" ) +
#   ylab(expression(d^{(2)})) +
#   theme(axis.text = element_text(size = 5),
#         axis.title = element_text(size = 12))
# 
# distance_plot

trimesh_removed_tsne_harps <- remove_long_edges(.data = distance_tsne_harps, benchmark_value = benchmark_tsne_harps,
                                              triangular_object = tr1_object_tsne_harps, distance_col = distance)

trimesh_removed_tsne_harps <- trimesh_removed_tsne_harps +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  #coord_cartesian(xlim = c(-25, 25), ylim = c(-12, 12)) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)

df_bin_train <- df_bin_tsne_harps
names(df_bin_train)[-1] <- paste0("avg_", names(df_bin_train)[-1])

error_df <- df_all_tsne_harps |>
  dplyr::left_join(df_bin_train, by = c("hb_id" = "hb_id")) ## Map high-D averaged/weighted mean coordinates

# prediction_df_join <- prediction_df_join |>
#   dplyr::left_join(data, by = c("ID" = "ID")) ## Map high-D data

for (i in 1:(NCOL(df_bin_train) - 1)) {

  error_df[ , paste0("abs_residual_", "x", i)] <- abs(error_df[ , paste0("x", i)] - error_df[ , paste0("avg_", "x", i)])

}

error_df <- error_df |>
  dplyr::mutate(total = rowSums(dplyr::pick(tidyselect::starts_with(paste0("abs_residual_", "x")))))

error_df <- error_df |>
  mutate(type = if_else(total <= 0, "no error",
                        if_else(total <= 0.2, "error 0-0.2",
                                if_else(total <= 0.3, "error 0.2-0.3",
                                        if_else(total <= 0.5, "error 0.3-0.5",
                                                if_else(total <= 1, "error 0.5-1",
                                                        "error greter than 1"))))))

plot_list2_harps_error <- error_df |>
    mutate(type = factor(type , levels = c("no error", "error 0-0.2", "error 0.2-0.3", "error 0.3-0.5", "error 0.5-1", "error greter than 1"))) |>
    ggplot(aes(x = tSNE1,
               y = tSNE2, color = type))+
    geom_point(alpha=0.5, size = 0.1) +
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#fee0d2", "#fcbba1",
                                         "#fc9272", "#fb6a4a", "#ef3b2c",
                                         "#cb181d", "#a50f15", "#99000d"))

```

```{r}
#| echo: false
#| fig-cap: "(a) 2D layout from tSNE (perplexity = 40) applied for the HARPS GTO dataset. Is this a best representation of the original data?, (b) Model in the 2D space with tSNE (<https://youtu.be/jxo_rPyGv9k>)"
#| label: fig-nldervisharpstSNE
#| fig-pos: h


plot_list2_harps + trimesh_removed_tsne_harps + plot_list2_harps_error +
  plot_layout(guides='collect', ncol = 3) &
  theme(legend.position='bottom', plot.tag = element_text(size = 8))

```


<!-- param set 1-->

- 5 clusters shows in 2D

- 3 clusters which are really close shows in high_d data with the model

```{r}
#| warning: false
#| echo: false

tSNE_data_harps <- read_rds("data/harps/harps_tsne_23.rds") 

plot_list2_harps <- tSNE_data_harps |>
    ggplot(aes(x = tSNE1,
               y = tSNE2, color = clusters))+
    geom_point(alpha=0.5) +
    coord_cartesian(xlim = c(-25, 20), ylim = c(-35, 25)) +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#b15928", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#6a3d9a", "#ff7f00", "#cab2d6", "#fdbf6f", "#ffff99", "#a6cee3", "#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#000000", "#bdbdbd")) +
  guides(color = guide_legend(title = "cluster"),
         color = guide_legend(nrow = 3)) +
 annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)



```

```{r}
#| warning: false
#| echo: false

## tSNE
## Prediction

shape_val_tsne_harps <- calculate_effective_shape_value(.data = tSNE_data_harps,
                                                      x = tSNE1, y = tSNE2)

num_bins_vec <- 1:21 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 5), c("number_of_bins", "number_of_observations", "total_error", "total_mse", "num_bins_x"))  ## Define column names

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  model_object <- fit_high_d_model(training_data = training_data_1, nldr_df_with_id = tSNE_data_harps, x = "tSNE1", y = "tSNE2", num_bins_x = num_bins_vec[i], shape_val = shape_val_tsne_harps,
                             is_bin_centroid = TRUE,
                             is_rm_lwd_hex = FALSE,
                             benchmark_to_rm_lwd_hex = NA,
                             is_avg_high_d = TRUE, column_start_text = "x")
  
  centroid_df_training <- model_object$df_bin_centroids
  avg_df_training <- model_object$df_bin
  
  pred_df_training <- predict_2d_embeddings(test_data = training_data_1, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, type_NLDR = "tSNE")
  
  eval_df_training <- generate_eval_df(data = training_data_1, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, col_start = "x")
  
  eval_df_training <- eval_df_training |>
    mutate(num_bins_x = num_bins_vec[i])
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  
  
}


## Add new column with data types

MSE_df_harps <- eval_data_training |>
  dplyr::mutate(data_type = "training",
                method = "tSNE")
```

```{r}
#| warning: false
#| echo: false

## To draw with AIC
aic_plot_harps <- ggplot(MSE_df_harps |> dplyr::filter(data_type == "training") |> dplyr::filter(method == "tSNE"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = 160, linetype="dashed", 
                color = "black", size=0.5) +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#e41a1c","#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("total number of bins")
## Effective number of bins along x-axis

mse_plot_harps <- ggplot(MSE_df_harps |> dplyr::filter(method == "tSNE"), aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
   geom_vline(xintercept = 160, linetype="dashed", 
                color = "black", size=0.5) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#e41a1c","#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("total number of bins")

```

```{r}
#| echo: false
#| fig-cap: "Goodness of fit statistics from UMAP applied to training S-curve dataset. What is the effective number of bins in each NLDR technique to create a 2D model? The MSE plot have a steep slope at the beginning, indicating that a smaller number of bins causes a larger amount of error. Then, the slope gradually declines or level off, indicating that a higher number of bins generates a smaller error. Using the elbow method, when the total number of bins is set to 144, the slope of the Mean Squared Error (MSE) plot experiences a sudden and noticeable change, resembling an elbow-like shape. This point indicates that adding less bins does not enough to capture the data structure."
#| label: fig-diagnosticpltHARPS2
##| out-width: 100%
#| fig-pos: H

aic_plot_harps + mse_plot_harps +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='none', plot.tag = element_text(size = 8))
```


```{r}
#| warning: false
#| echo: false

## Import data
# training_data_1 <- read_rds("data/harps/harps_data.rds")
# training_data_1 <- training_data_1 |>
#   mutate(ID = 1:NROW(training_data_1))
# 
# clusters <- training_data_1$cluster
# select_names <-  names(training_data_1)[-c(18, length(training_data_1))]
# 
# training_data_1 <- training_data_1 |> select(-cluster)
# names(training_data_1) <- append(paste0("x", 1:17), "ID")
# 
# tSNE_data_harps <- tSNE_data_harps |>
#   select(tSNE1, tSNE2) |>
#   mutate(ID = 1:NROW(tSNE_data_harps))

### tSNE

shape_val_tsne_harps <- calculate_effective_shape_value(.data = tSNE_data_harps,
                                                      x = tSNE1, y = tSNE2)

# num_bins_tsne_harps <- find_non_empty_bins(nldr_df = tSNE_data_harps, x = "tSNE1", y = "tSNE2", shape_val = shape_val_tsne_harps, non_empty_bins = num_non_empty_bins_harps)

num_bins_tsne_harps <- 9

## To extract bin centroids
hexbin_data_object_tsne_harps <- extract_hexbin_centroids(nldr_df = tSNE_data_harps, num_bins = num_bins_tsne_harps, shape_val = shape_val_tsne_harps, x = tSNE1, y = tSNE2)

df_bin_centroids_tsne_harps <- hexbin_data_object_tsne_harps$hexdf_data

## Identify bins with low-density
# identify_rm_bins <- find_low_density_hexagons(df_bin_centroids_tsne_harps, num_bins_tsne_harps, benchmark_rm_hex = 0.01)
# 
# df_bin_centroids_tsne_harps <- df_bin_centroids_tsne_harps |>
#   filter(!(hexID %in% identify_rm_bins))

tSNE_data_with_hb_id_harps <- tSNE_data_harps |>
  dplyr::mutate(hb_id = hexbin_data_object_tsne_harps$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_tsne_harps <- dplyr::bind_cols(training_data_1 |> dplyr::select(-ID), tSNE_data_with_hb_id_harps)

## Averaged on high-D
df_bin_tsne_harps <- avg_highD_data(.data = df_all_tsne_harps)

## Triangulate bin centroids
tr1_object_tsne_harps <- triangulate_bin_centroids(df_bin_centroids_tsne_harps, x, y)
tr_from_to_df_tsne_harps <- generate_edge_info(triangular_object = tr1_object_tsne_harps)

## Compute 2D distances
distance_tsne_harps <- cal_2d_dist(.data = tr_from_to_df_tsne_harps)

# distance_plot <- plot_dist(distance_tsne_harps) +
#   #ggtitle("(b)" ) +
#   ylab(expression(d^{(2)})) +
#   theme(axis.text = element_text(size = 5),
#         axis.title = element_text(size = 12))
# 
# distance_plot

## To find the benchmark value
benchmark_tsne_harps <- find_benchmark_value(.data = distance_tsne_harps, distance_col = "distance")
benchmark_tsne_harps <- 6

trimesh_removed_tsne_harps <- remove_long_edges(.data = distance_tsne_harps, benchmark_value = benchmark_tsne_harps,
                                              triangular_object = tr1_object_tsne_harps, distance_col = distance)

trimesh_removed_tsne_harps <- trimesh_removed_tsne_harps +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  coord_cartesian(xlim = c(-25, 20), ylim = c(-35, 25)) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)

df_bin_train <- df_bin_tsne_harps
names(df_bin_train)[-1] <- paste0("avg_", names(df_bin_train)[-1])

error_df <- df_all_tsne_harps |>
  dplyr::left_join(df_bin_train, by = c("hb_id" = "hb_id")) ## Map high-D averaged/weighted mean coordinates

# prediction_df_join <- prediction_df_join |>
#   dplyr::left_join(data, by = c("ID" = "ID")) ## Map high-D data

for (i in 1:(NCOL(df_bin_train) - 1)) {

  error_df[ , paste0("abs_residual_", "x", i)] <- abs(error_df[ , paste0("x", i)] - error_df[ , paste0("avg_", "x", i)])

}

error_df <- error_df |>
  dplyr::mutate(total = rowSums(dplyr::pick(tidyselect::starts_with(paste0("abs_residual_", "x")))))

error_df <- error_df |>
  mutate(type = if_else(total <= 0, "no error",
                        if_else(total <= 0.2, "error 0-0.2",
                                if_else(total <= 0.3, "error 0.2-0.3",
                                        if_else(total <= 0.5, "error 0.3-0.5",
                                                if_else(total <= 1, "error 0.5-1",
                                                        "error greter than 1"))))))

plot_list2_harps_error <- error_df |>
    mutate(type = factor(type , levels = c("no error", "error 0-0.2", "error 0.2-0.3", "error 0.3-0.5", "error 0.5-1", "error greter than 1"))) |>
    ggplot(aes(x = tSNE1,
               y = tSNE2, color = type))+
    geom_point(alpha=0.5, size = 0.1) +
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#fee0d2", "#fcbba1",
                                         "#fc9272", "#fb6a4a", "#ef3b2c",
                                         "#cb181d", "#a50f15", "#99000d"))

```

```{r}
#| echo: false
#| fig-cap: "(a) 2D layout from tSNE (perplexity = 23) applied for the HARPS GTO dataset. Is this a best representation of the original data?, (b) Model in the 2D space with tSNE (<https://youtu.be/VO_4SJEoAUA>)"
#| label: fig-nldervisharpstSNE2
#| fig-pos: h


plot_list2_harps + trimesh_removed_tsne_harps + plot_list2_harps_error +
  plot_layout(guides='collect', ncol = 3) &
  theme(legend.position='bottom', plot.tag = element_text(size = 8))

```

<!-- param set 2-->


```{r}
#| warning: false
#| echo: false

tSNE_data_harps <- read_rds("data/harps/harps_tsne_91.rds") 

plot_list2_harps <- tSNE_data_harps |>
    ggplot(aes(x = tSNE1,
               y = tSNE2, color = clusters))+
    geom_point(alpha=0.5) +
    coord_cartesian(xlim = c(-8, 7), ylim = c(-10, 16)) +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#b15928", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#6a3d9a", "#ff7f00", "#cab2d6", "#fdbf6f", "#ffff99", "#a6cee3", "#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#000000", "#bdbdbd")) +
  guides(color = guide_legend(title = "cluster"),
         color = guide_legend(nrow = 3)) +
 annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)



```

```{r}
#| warning: false
#| echo: false

## tSNE
## Prediction

shape_val_tsne_harps <- calculate_effective_shape_value(.data = tSNE_data_harps,
                                                      x = tSNE1, y = tSNE2)

num_bins_vec <- 1:21 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 5), c("number_of_bins", "number_of_observations", "total_error", "total_mse", "num_bins_x"))  ## Define column names

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  model_object <- fit_high_d_model(training_data = training_data_1, nldr_df_with_id = tSNE_data_harps, x = "tSNE1", y = "tSNE2", num_bins_x = num_bins_vec[i], shape_val = shape_val_tsne_harps,
                             is_bin_centroid = TRUE,
                             is_rm_lwd_hex = FALSE,
                             benchmark_to_rm_lwd_hex = NA,
                             is_avg_high_d = TRUE, column_start_text = "x")
  
  centroid_df_training <- model_object$df_bin_centroids
  avg_df_training <- model_object$df_bin
  
  pred_df_training <- predict_2d_embeddings(test_data = training_data_1, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, type_NLDR = "tSNE")
  
  eval_df_training <- generate_eval_df(data = training_data_1, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, col_start = "x")
  
  eval_df_training <- eval_df_training |>
    mutate(num_bins_x = num_bins_vec[i])
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  
  
}


## Add new column with data types

MSE_df_harps <- eval_data_training |>
  dplyr::mutate(data_type = "training",
                method = "tSNE")
```

```{r}
#| warning: false
#| echo: false

## To draw with AIC
aic_plot_harps <- ggplot(MSE_df_harps |> dplyr::filter(data_type == "training") |> dplyr::filter(method == "tSNE"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = 180, linetype="dashed", 
                color = "black", size=0.5) +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#e41a1c","#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("total number of bins")
## Effective number of bins along x-axis

mse_plot_harps <- ggplot(MSE_df_harps |> dplyr::filter(method == "tSNE"), aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
   geom_vline(xintercept = 180, linetype="dashed", 
                color = "black", size=0.5) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#e41a1c","#377eb8", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("total number of bins")

```

```{r}
#| echo: false
#| fig-cap: "Goodness of fit statistics from UMAP applied to training S-curve dataset. What is the effective number of bins in each NLDR technique to create a 2D model? The MSE plot have a steep slope at the beginning, indicating that a smaller number of bins causes a larger amount of error. Then, the slope gradually declines or level off, indicating that a higher number of bins generates a smaller error. Using the elbow method, when the total number of bins is set to 144, the slope of the Mean Squared Error (MSE) plot experiences a sudden and noticeable change, resembling an elbow-like shape. This point indicates that adding less bins does not enough to capture the data structure."
#| label: fig-diagnosticpltHARPS3
##| out-width: 100%
#| fig-pos: H

aic_plot_harps + mse_plot_harps +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='none', plot.tag = element_text(size = 8))
```

```{r}
#| warning: false
#| echo: false

## Import data
# training_data_1 <- read_rds("data/harps/harps_data.rds")
# training_data_1 <- training_data_1 |>
#   mutate(ID = 1:NROW(training_data_1))
# 
# clusters <- training_data_1$cluster
# select_names <-  names(training_data_1)[-c(18, length(training_data_1))]
# 
# training_data_1 <- training_data_1 |> select(-cluster)
# names(training_data_1) <- append(paste0("x", 1:17), "ID")
# 
# tSNE_data_harps <- tSNE_data_harps |>
#   select(tSNE1, tSNE2) |>
#   mutate(ID = 1:NROW(tSNE_data_harps))

### tSNE

shape_val_tsne_harps <- calculate_effective_shape_value(.data = tSNE_data_harps,
                                                      x = tSNE1, y = tSNE2)

# num_bins_tsne_harps <- find_non_empty_bins(nldr_df = tSNE_data_harps, x = "tSNE1", y = "tSNE2", shape_val = shape_val_tsne_harps, non_empty_bins = num_non_empty_bins_harps)
num_bins_tsne_harps <- 9

## To extract bin centroids
hexbin_data_object_tsne_harps <- extract_hexbin_centroids(nldr_df = tSNE_data_harps, num_bins = num_bins_tsne_harps, shape_val = shape_val_tsne_harps, x = tSNE1, y = tSNE2)

df_bin_centroids_tsne_harps <- hexbin_data_object_tsne_harps$hexdf_data

## Identify bins with low-density
# identify_rm_bins <- find_low_density_hexagons(df_bin_centroids_tsne_harps, num_bins_tsne_harps, benchmark_rm_hex = 0.01)
# 
# df_bin_centroids_tsne_harps <- df_bin_centroids_tsne_harps |>
#   filter(!(hexID %in% identify_rm_bins))

tSNE_data_with_hb_id_harps <- tSNE_data_harps |>
  dplyr::mutate(hb_id = hexbin_data_object_tsne_harps$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_tsne_harps <- dplyr::bind_cols(training_data_1 |> dplyr::select(-ID), tSNE_data_with_hb_id_harps)

## Averaged on high-D
df_bin_tsne_harps <- avg_highD_data(.data = df_all_tsne_harps)

## Triangulate bin centroids
tr1_object_tsne_harps <- triangulate_bin_centroids(df_bin_centroids_tsne_harps, x, y)
tr_from_to_df_tsne_harps <- generate_edge_info(triangular_object = tr1_object_tsne_harps)

## Compute 2D distances
distance_tsne_harps <- cal_2d_dist(.data = tr_from_to_df_tsne_harps)

# distance_plot <- plot_dist(distance_tsne_harps) +
#   #ggtitle("(b)" ) +
#   ylab(expression(d^{(2)})) +
#   theme(axis.text = element_text(size = 5),
#         axis.title = element_text(size = 12))
# 
# distance_plot

## To find the benchmark value
benchmark_tsne_harps <- find_benchmark_value(.data = distance_tsne_harps, distance_col = "distance")
benchmark_tsne_harps <- 2.5

trimesh_removed_tsne_harps <- remove_long_edges(.data = distance_tsne_harps, benchmark_value = benchmark_tsne_harps,
                                              triangular_object = tr1_object_tsne_harps, distance_col = distance)

trimesh_removed_tsne_harps <- trimesh_removed_tsne_harps +
  # xlab(expression(C[x]^{(2)})) + ylab(expression(C[y]^{(2)})) +
  # theme(axis.text = element_text(size = 5),
  #       axis.title = element_text(size = 7)) +
  geom_point(colour = "#33a02c", size = 0.5) +
  coord_cartesian(xlim = c(-8, 7), ylim = c(-10, 16)) +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)

df_bin_train <- df_bin_tsne_harps
names(df_bin_train)[-1] <- paste0("avg_", names(df_bin_train)[-1])

error_df <- df_all_tsne_harps |>
  dplyr::left_join(df_bin_train, by = c("hb_id" = "hb_id")) ## Map high-D averaged/weighted mean coordinates

# prediction_df_join <- prediction_df_join |>
#   dplyr::left_join(data, by = c("ID" = "ID")) ## Map high-D data

for (i in 1:(NCOL(df_bin_train) - 1)) {

  error_df[ , paste0("abs_residual_", "x", i)] <- abs(error_df[ , paste0("x", i)] - error_df[ , paste0("avg_", "x", i)])

}

error_df <- error_df |>
  dplyr::mutate(total = rowSums(dplyr::pick(tidyselect::starts_with(paste0("abs_residual_", "x")))))

error_df <- error_df |>
  mutate(type = if_else(total <= 0, "no error",
                        if_else(total <= 0.2, "error 0-0.2",
                                if_else(total <= 0.3, "error 0.2-0.3",
                                        if_else(total <= 0.5, "error 0.3-0.5",
                                                if_else(total <= 1, "error 0.5-1",
                                                        "error greter than 1"))))))

plot_list2_harps_error <- error_df |>
    mutate(type = factor(type , levels = c("no error", "error 0-0.2", "error 0.2-0.3", "error 0.3-0.5", "error 0.5-1", "error greter than 1"))) |>
    ggplot(aes(x = tSNE1,
               y = tSNE2, color = type))+
    geom_point(alpha=0.5, size = 0.1) +
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#fee0d2", "#fcbba1",
                                         "#fc9272", "#fb6a4a", "#ef3b2c",
                                         "#cb181d", "#a50f15", "#99000d"))
```

```{r}
#| echo: false
#| fig-cap: "(a) 2D layout from tSNE (perplexity = 91) applied for the HARPS GTO dataset. Is this a best representation of the original data?, (b) Model in the 2D space with tSNE (<https://youtu.be/vLvRfcogft8>)"
#| label: fig-nldervisharpstSNE3
#| fig-pos: h


plot_list2_harps + trimesh_removed_tsne_harps + plot_list2_harps_error +
  plot_layout(guides='collect', ncol = 3) &
  theme(legend.position='bottom', plot.tag = element_text(size = 8))

```

-->

<!--
**(b) Determine the shape parameter** ($s$)
          
In this step, we determine the shape parameter ($s$) for the hexagonal bins, which significantly influences their shape and arrangement within the grid. The $s$ in the hexagonal binning algorithm is defined as the ratio of the height ($y$) to the width ($x$) of the plotting region as defined in @eq-equation1 [@Carr2013]. 
          
$$
s = \frac{y}{x}
$$ {#eq-equation1}
            
The shape parameter ($s$) of our algorithm is calculated as the ratio of the ranges of 2D embedding components, where $r_1$ and $r_2$ represent the ranges of 2D embedding components 1 and component 2, respectively (see @eq-equation2).
            
$$
s = \frac{r_2}{r_1}
$$ {#eq-equation2}


<!--UMAP parm 2-->

```{r}
#| warning: false
#| echo: false

## Import data 
training_data_pbmc <- read_rds("data/pbmc/pbmc_3k_festem/pbmc_pca_50.rds")
training_data_pbmc <- training_data_pbmc[, 1:15] |>
  mutate(ID = 1:NROW(training_data_pbmc))

UMAP_pbmc <- read_rds("data/pbmc/pbmc_umap_15_min_dist_0.99_metric_cosine.rds")

class_avg <- UMAP_pbmc |>
  group_by(cell_label) |>
  summarise(
    UMAP1 = median(UMAP1),
    UMAP2 = median(UMAP2)
  ) |>
  mutate(cell_label = as.numeric(cell_label)) |>
  arrange(cell_label)

class_avg$cell_label <- as.factor(class_avg$cell_label)

levels(class_avg$cell_label) <- c("Memory \nCD4 T", "Naive CD4 T", "CD14+ Mono",  "B", "CD8 T", "FCGR3A+ \n Mono", "NK", "M-MDSC\n-like", "CD27-CD+ \n Memory T", "DC")

plot_list2_pbmc <- UMAP_pbmc |>
    ggplot(aes(x = UMAP1,
               y = UMAP2, color = cell_label))+
    geom_point(alpha=0.5) +
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(legend.position = "none", plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#b15928", "#1f78b4", "#cab2d6", "#ccebc5", "#fb9a99", "#e31a1c", "#6a3d9a", "#ff7f00", "#ffed6f", "#fdbf6f", "#ffff99", "#a6cee3", "#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#b2df8a", "#bc80bd", "#33a02c", "#ccebc5", "#ffed6f", "#000000", "#bdbdbd")) +
  geom_text(aes(x=UMAP1,y = UMAP2,label = cell_label), data = class_avg,inherit.aes = F, color = "black",fontface = "bold",size = 2) +
  annotate(geom = 'text', label = 'a', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3) 
```

```{r}
#| warning: false
#| echo: false

## UMAP
## Prediction

shape_value_pbmc <- calculate_effective_shape_value(.data = UMAP_pbmc,
                                                      x = UMAP1, y = UMAP2)

num_bins_vec <- 1:35 ## Number of bins along the x-axis

vec <- stats::setNames(rep("", 5), c("number_of_bins", "number_of_observations", "total_error", "total_mse", "num_bins_x"))  ## Define column names

eval_data_training <- dplyr::bind_rows(vec)[0, ]
eval_data_training <- eval_data_training |>
  dplyr::mutate_if(is.character, as.numeric)

for (i in 1:length(num_bins_vec)) {
  
  model_object <- fit_high_d_model(training_data = training_data_pbmc, nldr_df_with_id = UMAP_pbmc, x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_vec[i], shape_val = shape_value_pbmc,
                             is_bin_centroid = TRUE,
                             is_rm_lwd_hex = FALSE,
                             benchmark_to_rm_lwd_hex = NA,
                             is_avg_high_d = TRUE, column_start_text = "PC_")
  
  centroid_df_training <- model_object$df_bin_centroids
  avg_df_training <- model_object$df_bin
  
  pred_df_training <- predict_2d_embeddings(test_data = training_data_pbmc, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, type_NLDR = "UMAP")
  
  eval_df_training <- generate_eval_df(data = training_data_pbmc, prediction_df = pred_df_training, df_bin_centroids = centroid_df_training, df_bin = avg_df_training, col_start = "PC_")
  
  eval_df_training <- eval_df_training |>
    mutate(num_bins_x = num_bins_vec[i])
  
  eval_data_training <- dplyr::bind_rows(eval_data_training, eval_df_training)
  
  
}


## Add new column with data types

MSE_df_pbmc <- eval_data_training |>
  dplyr::mutate(data_type = "training",
                method = "UMAP")
```

```{r}
#| warning: false
#| echo: false

## To draw with AIC
aic_plot_pbmc <- ggplot(MSE_df_pbmc |> dplyr::filter(data_type == "training") |> dplyr::filter(method == "UMAP"), aes(x = number_of_bins,
                                                                                 y = total_error,
                                                                                 color = method
)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = 192, linetype="dashed", 
                color = "red", size=0.5) +
  #geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  #annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=-5000, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  scale_colour_manual(values = c("#377eb8", "#e41a1c", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("AIC") +
  xlab("total number of bins")
## Effective number of bins along x-axis

mse_plot_pbmc <- ggplot(MSE_df_pbmc |> dplyr::filter(method == "UMAP"), aes(x = number_of_bins,
                                       y = total_mse,
                                       color = method
)) +
  geom_point() +
  geom_line() +
   geom_vline(xintercept = 192, linetype="dashed", 
                color = "red", size=0.5) +
  theme_light() +
  theme(legend.position = "none", legend.title = element_blank(), plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title = element_text(size = 7),
        axis.text = element_text(size = 7)) +
  # geom_vline(xintercept = NROW(full_grid_with_hexbin_id)) +
  # annotate("text", x= (NROW(full_grid_with_hexbin_id) - 10), y=0.25, label=paste0("effective number of bins = ", as.character(NROW(full_grid_with_hexbin_id))), angle=90) +
  scale_colour_manual(values = c("#377eb8", "#e41a1c", "#4daf4a", "#984ea3", "#ff7f00")) +
  ylab("MSE") +
  xlab("total number of bins")

```

```{r}
#| echo: false
#| fig-cap: "Goodness of fit statistics from UMAP applied to training S-curve dataset. What is the effective number of bins in each NLDR technique to create a 2D model? The MSE plot have a steep slope at the beginning, indicating that a smaller number of bins causes a larger amount of error. Then, the slope gradually declines or level off, indicating that a higher number of bins generates a smaller error. Using the elbow method, when the total number of bins is set to 144, the slope of the Mean Squared Error (MSE) plot experiences a sudden and noticeable change, resembling an elbow-like shape. This point indicates that adding less bins does not enough to capture the data structure."
#| label: fig-diagnosticpltPBMC2
##| out-width: 100%
#| fig-pos: H

aic_plot_pbmc + mse_plot_pbmc +
  plot_annotation(tag_levels = 'a') +
  plot_layout(guides='collect', ncol = 2) &
  theme(legend.position='none', plot.tag = element_text(size = 8))
```

```{r}
#| warning: false
#| echo: false
shape_value_pbmc <- calculate_effective_shape_value(.data = UMAP_pbmc,
                                                      x = UMAP1, y = UMAP2) ## 0.8772751

# num_bins_pbmc <- find_non_empty_bins(nldr_df = UMAP_pbmc, x = "UMAP1", y = "UMAP2", shape_val = shape_value_pbmc, non_empty_bins = num_non_empty_bins_pbmc)
num_bins_pbmc <-  11

## To extract bin centroids
hexbin_data_object_pbmc <- extract_hexbin_centroids(nldr_df = UMAP_pbmc,
                                                      num_bins = num_bins_pbmc,
                                                      shape_val = shape_value_pbmc, x = UMAP1, y = UMAP2)

df_bin_centroids_pbmc <- hexbin_data_object_pbmc$hexdf_data


UMAP_pbmc_with_hb_id <- UMAP_pbmc |>
  dplyr::mutate(hb_id = hexbin_data_object_pbmc$hb_data@cID)

## To generate a data set with high-D and 2D training data
df_all_pbmc <- dplyr::bind_cols(training_data_pbmc |> dplyr::select(-ID), UMAP_pbmc_with_hb_id)

## Averaged on high-D
df_bin_pbmc <- avg_highD_data(.data = df_all_pbmc, column_start_text = "PC")

## Triangulate bin centroids
tr1_object_pbmc <- triangulate_bin_centroids(df_bin_centroids_pbmc, x, y)
tr_from_to_df_pbmc <- generate_edge_info(triangular_object = tr1_object_pbmc)

## Compute 2D distances
distance_pbmc <- cal_2d_dist(.data = tr_from_to_df_pbmc)

# distance_plot <- plot_dist(distance_pbmc) +
#   #ggtitle("(b)" ) +
#   ylab(expression(d^{(2)})) +
#   theme(axis.text = element_text(size = 5),
#         axis.title = element_text(size = 12))
# 
# distance_plot

## To find the benchmark value
benchmark_pbmc <- find_benchmark_value(.data = distance_pbmc, distance_col = distance)
#benchmark_pbmc <- 1.049766 
benchmark_pbmc <- 2.5

trimesh_removed_pbmc_umap <- remove_long_edges(.data = distance_pbmc, benchmark_value = benchmark_pbmc,
                                                 triangular_object = tr1_object_pbmc, distance_col = distance)

trimesh_removed_pbmc_umap <- trimesh_removed_pbmc_umap +
  geom_point(size = 0.005, colour = "#33a02c") +
  #ggtitle("(b)") +
  theme_linedraw() +
  theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
        axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  annotate(geom = 'text', label = 'b', x = -Inf, y = Inf, hjust = -0.5, vjust = 1.5, size = 3)

df_bin_train <- df_bin_pbmc
names(df_bin_train)[-1] <- paste0("avg_", names(df_bin_train)[-1])

error_df <- df_all_pbmc |>
  dplyr::left_join(df_bin_train, by = c("hb_id" = "hb_id")) ## Map high-D averaged/weighted mean coordinates

# prediction_df_join <- prediction_df_join |>
#   dplyr::left_join(data, by = c("ID" = "ID")) ## Map high-D data

for (i in 1:(NCOL(df_bin_train) - 1)) {
  
  error_df[ , paste0("abs_residual_", "PC_", i)] <- abs(error_df[ , paste0("PC_", i)] - error_df[ , paste0("avg_", "PC_", i)])
  
}

error_df <- error_df |>
  dplyr::mutate(total = rowSums(dplyr::pick(tidyselect::starts_with(paste0("abs_residual_", "PC_")))))

# library(ggbeeswarm)
# error_df$group <- "1"
# ggplot(error_df, aes(x = group, y = total)) +
#   geom_quasirandom()+
#   ylim(0, max(unlist(error_df$total))+ 0.5) + coord_flip()

### The minimum error is 0 and the maximum is 42.17439
### There is lot of points with error 0,

error_df <- error_df |>
  mutate(type = if_else(total <= 2, "error 2 or less",
                        if_else(total <= 10, "error 2-10",
                                if_else(total <= 15, "error 10-15",
                                        if_else(total <= 20, "error 15-20",
                                                if_else(total <= 25, "error 20-25",
                                                        if_else(total <= 30, "error 25-30",
                                                                if_else(total <= 35, "error 30-35", "error greter than 35"))))))))

plot_list2_pbmc_error <- error_df |>
    mutate(type = factor(type , levels = c("error 2 or less", "error 2-10", "error 10-15", "error 15-20", "error 20-25", "error 25-30", "error 30-35", "error greter than 35"))) |>
    ggplot(aes(x = UMAP1,
               y = UMAP2, color = type))+
    geom_point(alpha=0.5, size = 0.1) +
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5, size = 18, face = "bold")) + #ggtitle("(a)") +
  theme_linedraw() +
    theme(plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
              axis.title.x = element_blank(), axis.title.y = element_blank(),
              axis.text.x = element_blank(), axis.ticks.x = element_blank(),
              axis.text.y = element_blank(), axis.ticks.y = element_blank(),
              panel.grid.major = element_blank(), panel.grid.minor = element_blank(), #change legend key width
        legend.title = element_text(size=5), #change legend title font size
        legend.text = element_text(size=4),
         legend.key.height = unit(0.25, 'cm'),
         legend.key.width = unit(0.25, 'cm')) +
  scale_color_manual(values=c("#fee0d2", "#fcbba1",
                                         "#fc9272", "#fb6a4a", "#ef3b2c",
                                         "#cb181d", "#a50f15", "#99000d"))

```

```{r}
#| echo: false
#| fig-cap: "(a) 2D layout from UMAP (n_neighbors = 15, min_dist = 0.99, metric = cosine) applied for the PBMC3k dataset. Is this a best representation of the original data?, (b)  Model in the 2D space with UMAP (<>)"
#| label: fig-nldervisPBMCUMAP2
#| out-width: 100%
#| fig-pos: h

plot_list2_pbmc + trimesh_removed_pbmc_umap + plot_list2_pbmc_error +
plot_layout(guides='collect', ncol=3) &
  theme(legend.position='bottom')
```
-->
